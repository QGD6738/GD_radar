C51 COMPILER V9.60.0.0   COMMAND                                                           08/08/2020 16:35:49 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE COMMAND
OBJECT MODULE PLACED IN .\src\Command.OBJ
COMPILER INVOKED BY: c:\SiliconLabs\SimplicityStudio\v4\developer\toolchains\keil_8051\9.60\BIN\C51.exe C:\WorkSpace\3_C
                    -HAN\4_M80\1_CODE\DFSK-F516-EFM8BB21F16G-C-QFN20_20200107\src\Command.c OMF2 SMALL DEBUG OBJECTEXTEND ROM(LARGE) WARNINGL
                    -EVEL(2) FLOATFUZZY(3) OPTIMIZE(9,SPEED) DEFINE(NDEBUG=1) INTVECTOR(0X0000) INTPROMOTE INCDIR(C:\WorkSpace\3_CHAN\4_M80\1
                    -_CODE\DFSK-F516-EFM8BB21F16G-C-QFN20_20200107\inc;C:/SiliconLabs/SimplicityStudio/v4/developer/sdks/8051/v4.1.7//Device/
                    -shared/si8051base;C:/SiliconLabs/SimplicityStudio/v4/developer/sdks/8051/v4.1.7//Device/EFM8BB2/inc) REGFILE(DFSK-F516-E
                    -FM8BB21F16G-C-QFN20_20200107.ORC) PRINT(.\src\Command.lst) COND PAGEWIDTH(120) PAGELENGTH(65) OBJECT(.\src\Command.OBJ)

line level    source

   1          #include "cpu.h"
   2          #include "Timer.h"
   3          #include "Serial.h"
   4          #include "Uart.h"
   5          #include "Command.h"
   6          #include "DetectObj.h"
   7          #include "Adc.h"
   8          #include "EFM8BB2_FlashPrimitives.h"
   9          
  10          stCmd xdata Cmd;
  11          const Self_Straighten[6]={0,3,2,0,5,4};
  12          
  13          void Cmd_InitVariable(void)
  14          {
  15   1              Cmd.bID = ID_RL;
  16   1              Cmd.wWaitTime = MASTER_WORK_TIME_MAX;
  17   1              Cmd.wBackData = 0;
  18   1              Cmd.CmdStatus = MST_DRV_SENSOR_SELFCHECK;
  19   1              //Cmd.CmdCalibration;
  20   1              //Cmd.bOverCnt[ID_SUM];
  21   1              //Cmd.bSensorErrCnt[ID_SUM];
  22   1              //Cmd.bSensorRun[ID_SUM];
  23   1              Cmd.bUsedSnrNUM = 2;
  24   1              //Cmd.bVechInfoErrCnt;
  25   1              //Cmd.bDistance[ID_SUM];
  26   1              //Cmd.bObsorient[ID_SUM];
  27   1              Cmd.bBuzzerInfo = 3;
  28   1              //Cmd.Debug_ErrCnt[ID_SUM];
  29   1              //Cmd.Debug_OKCnt[ID_SUM];
  30   1              //Cmd.Debug_bVechInfoErrCnt = 0;
  31   1              //Cmd.Debug_bVechInfoOKCnt = 0;
  32   1      }
  33          
  34          
  35          void Cmd_ReadID(void)
  36          {
  37   1      
  38   1      
  39   1      }
  40          
  41          void Cmd_GetVechileMode(void)
  42          {
  43   1              BYTE mode_temp;
  44   1              mode_temp = 0;
  45   1              Cmd.wWaitTime = 170;
  46   1      
  47   1              CommunicaitonMode(COM_Internal);
  48   1              //The delay time need to adjust
  49   1              Delay1us(START_UART_DELAY);
  50   1              while(Cmd.wWaitTime)
  51   1              {
C51 COMPILER V9.60.0.0   COMMAND                                                           08/08/2020 16:35:49 PAGE 2   

  52   2                      if(bTimeFlag)
  53   2                      {
  54   3                              bTimeFlag = FALSE;
  55   3                              Cmd.wWaitTime--;
  56   3                              if(Cmd.wWaitTime%50 == 0)
  57   3                              {
  58   4                                      Cmd_SendReqVechiModetoBCM();
  59   4                              }
  60   3                              if(Uart0RX_OK_Flag == Rec_VechiMode)
  61   3                              {
  62   4                                      if((MsgBCM_Mode._bit.VechiMode&0xF0) == 0x30)
  63   4                                      {
  64   5                                              Cmd.bUsedSnrNUM = 3;
  65   5                                      }
  66   4                                      else if((MsgBCM_Mode._bit.VechiMode&0xF0) == 0x50)
  67   4                                      {
  68   5                                              Cmd.bUsedSnrNUM = 5;
  69   5                                      }
  70   4                                      mode_temp = MsgBCM_Mode._bit.VechiMode;
  71   4                                      Flash_WriteVechileMode(mode_temp);
  72   4                                      break;
  73   4                              }
  74   3                      }
  75   2                      CLR_WDT;
  76   2              }
  77   1      
  78   1              if(Cmd.wWaitTime == 0)
  79   1              {
  80   2                      mode_temp = Flash_ReadVechileMode();
  81   2                      Cmd.bUsedSnrNUM = (mode_temp >> 4);
  82   2                      if(Cmd.bUsedSnrNUM != 3 && Cmd.bUsedSnrNUM != 5)
  83   2                      {
  84   3                              Cmd.bUsedSnrNUM = 5;
  85   3                      }
  86   2              }
  87   1              CommunicaitonMode(NO_Com);
  88   1      }
  89          
  90          
  91          
  92          void Cmd_Process(void)
  93          {
  94   1              BYTE i,self_temp,cnt;
  95   1      
  96   1          if(bSensorCheckFlag == TRUE)
  97   1          {
  98   2              DetInfo.bDetTriggerFlag = TRUE;
  99   2              return;
 100   2          }
 101   1      
 102   1              switch(Cmd.CmdStatus)
 103   1                      {
 104   2                              case MST_DRV_SENSOR_SELFCHECK:
 105   2                              {
 106   3                                      Srl_SendData(HEAD_2500, Cmd.bID, ID_LEN_BIT, 0, 0);
 107   3                                      Cmd.wWaitTime = MASTER_TXANDRX_TIME_OVER_MAX_TEST;
 108   3                                      Cmd.CmdStatus = MST_WAIT_SELFCHECK;
 109   3                                      break;
 110   3                              }
 111   2                              case MST_WAIT_SELFCHECK:
 112   2                              {
 113   3                                      if(Cmd.wWaitTime > 0)
 114   3                                      {
C51 COMPILER V9.60.0.0   COMMAND                                                           08/08/2020 16:35:49 PAGE 3   

 115   4                                              if(Serial.CmdHead_Rx == CMD_HEAD_1000) //Receive data efficacious)
 116   4                                              {
 117   5                                                      if(Serial.bValid == TRUE)
 118   5                                                      {
 119   6                                                              Serial.bValid = FALSE;
 120   6                                                              Cmd.bSensorErrCnt[Cmd.bID] = 0;
 121   6                                                              if((Serial.byData&0x07) == Cmd.bID)
 122   6                                                              {
 123   7                                                                      Cmd_SaveData();
 124   7                                                                      Cmd_NextSensorSelf();
 125   7                                                              }
 126   6                                                              else
 127   6                                                              {
 128   7                                                                      Cmd.wWaitTime = 1;
 129   7                                                              }
 130   6                                                      }
 131   5                                              }
 132   4                                              Cmd.wWaitTime--;
 133   4                                      }
 134   3                                      else
 135   3                                      {
 136   4                                              Cmd.CmdStatus = MST_DRV_SENSOR_SELFCHECK;
 137   4                                              if((++Cmd.bSensorErrCnt[Cmd.bID]) >= 3)
 138   4                                              {
 139   5                                                      Cmd.bSensorErrCnt[Cmd.bID] = 0;
 140   5                                                      DiagInfo.bSelfCheckResult[Cmd.bID] = 1;
 141   5                                                      Cmd_NextSensorSelf();
 142   5                                              }
 143   4                                      }
 144   3      
 145   3                                      break;
 146   3                              }
 147   2      
 148   2                              case MST_SEND_SELF_TO_BCM:
 149   2                              {
 150   3      #if(TEST_CODE_FIXED_ID == TRUE)
                      {
                              DiagInfo.bSelfCheckResult[ID_RL] = 0;
                              DiagInfo.bSelfCheckResult[ID_RML] = 0;
                              DiagInfo.bSelfCheckResult[ID_RR] = 0;
                              DiagInfo.bSelfCheckResult[ID_FL] = 0;
                              DiagInfo.bSelfCheckResult[ID_FR] = 0;
                      }
              #endif
 159   3                                      self_temp = 0;
 160   3                                      cnt = 0;
 161   3                                      for(i=1;i<(Cmd.bUsedSnrNUM+1);i++)
 162   3                                      {
 163   4                                              self_temp |= DiagInfo.bSelfCheckResult[i] << Self_Straighten[i];
 164   4                                      }
 165   3                                      MsgRadar_Self._Byte[1] = self_temp;
 166   3      
 167   3                                              if(DiagInfo.bSelfCheckResult[ID_RL] + DiagInfo.bSelfCheckResult[ID_RML])
 168   3                                              {
 169   4                                                      cnt = 25;
 170   4                                              }
 171   3                                              else
 172   3                                              {
 173   4                                                      cnt = 5;
 174   4                                              }
 175   3                                              /*
 176   3                                      if(Cmd.bUsedSnrNUM == 3)
 177   3                                      {
C51 COMPILER V9.60.0.0   COMMAND                                                           08/08/2020 16:35:49 PAGE 4   

 178   3                                              if(DiagInfo.bSelfCheckResult[ID_RL] + DiagInfo.bSelfCheckResult[ID_RML] + \
 179   3                                                      DiagInfo.bSelfCheckResult[ID_RR])
 180   3                                              {
 181   3                                                      cnt = 25;
 182   3                                              }
 183   3                                              else
 184   3                                              {
 185   3                                                      cnt = 5;
 186   3                                              }
 187   3                                      }
 188   3                                      else if(Cmd.bUsedSnrNUM == 5)
 189   3                                      {
 190   3                                              if(DiagInfo.bSelfCheckResult[ID_RL] + DiagInfo.bSelfCheckResult[ID_RML] + \
 191   3                                                 DiagInfo.bSelfCheckResult[ID_RR] + DiagInfo.bSelfCheckResult[ID_FL] + \
 192   3                                                 DiagInfo.bSelfCheckResult[ID_FR])
 193   3                                              {
 194   3                                                      cnt = 25;
 195   3                                              }
 196   3                                              else
 197   3                                              {
 198   3                                                      cnt = 5;
 199   3                                              }
 200   3                                      }
 201   3                                      */
 202   3                                      CommunicaitonMode(COM_Internal);
 203   3                                      for(i=0;i<cnt;i++)
 204   3                                      {
 205   4                                              Cmd_SendSelfChecktoBCM();
 206   4                                              Delay1ms(10);
 207   4                                      }
 208   3                                      Cmd.CmdStatus = MST_DRV_SENSOR;
 209   3                                      Cmd.bID = ID_RL;
 210   3                                      //CommunicaitonMode(COM_Internal);
 211   3                                      break;
 212   3                              }
 213   2      
 214   2                              case MST_DRV_SENSOR:
 215   2                              {
 216   3                                      Delay1ms(5);    //It is must,for after Communit with MP5,the inter communit wrong rate too high
 217   3                                      Srl_SendData(HEAD_800, Cmd.bID, ID_LEN_BIT, 0, 0);
 218   3                                      Cmd.wWaitTime = MASTER_WORK_TIME_MAX;
 219   3                                      Cmd.CmdStatus = MST_WAIT_SENSOR_DATA;
 220   3                                      break;
 221   3                              }
 222   2      
 223   2                              case MST_WAIT_SENSOR_DATA:
 224   2                              {
 225   3                                      if(Cmd.wWaitTime > 0)
 226   3                                      {
 227   4                                              if(Serial.CmdHead_Rx == CMD_HEAD_1000) //Receive data efficacious)
 228   4                                              {
 229   5                                                      if(Serial.bValid == TRUE)
 230   5                                                      {
 231   6                                                              Serial.bValid = FALSE;
 232   6                                                              if((Serial.byData&0x07) == Cmd.bID)
 233   6                                                              {
 234   7                                                                      Cmd.bSensorErrCnt[Cmd.bID] = 0;
 235   7                                                                      Cmd_SaveData();
 236   7                                                              Cmd.Debug_OKCnt[Cmd.bID]++;
 237   7                                                                      Cmd_NextSensorDet(FALSE);
 238   7                                                              }
 239   6                                                              else
 240   6                                                              {
C51 COMPILER V9.60.0.0   COMMAND                                                           08/08/2020 16:35:49 PAGE 5   

 241   7                                                                      Cmd.wWaitTime = 1;
 242   7                                                              }
 243   6                                                      }
 244   5                                              }
 245   4                                              Cmd.wWaitTime--;
 246   4                                      }
 247   3                                      else
 248   3                                      {
 249   4                                       Cmd.Debug_ErrCnt[Cmd.bID]++;
 250   4                                              if(++Cmd.bSensorErrCnt[Cmd.bID] >= SENSOR_EER_THRE_SENSOR)
 251   4                                              {
 252   5                                                      Cmd.bSensorErrCnt[Cmd.bID] = SENSOR_EER_THRE_SENSOR;
 253   5                                                      DiagInfo.bSelfCheckResult[Cmd.bID] = 1;
 254   5                                                      NearestData.bEachNearestDistance[Cmd.bID] = NO_OBJ;
 255   5                                              }
 256   4                                                      //TEST
 257   4      //                                      if(Cmd.bSensorErrCnt[1] >= SENSOR_EER_THRE_SENSOR)
 258   4      //                                      {
 259   4      //                                              Cmd.bSensorErrCnt[1] = SENSOR_EER_THRE_SENSOR;
 260   4      //                                      }
 261   4      //                                      if(Cmd.bSensorErrCnt[3] >= 3)
 262   4      //                                      {
 263   4      //                                              Cmd.bSensorErrCnt[3] = 3;
 264   4      //                                      }
 265   4      //                                      if(Cmd.bSensorErrCnt[4] >= 3)
 266   4      //                                      {
 267   4      //                                              Cmd.bSensorErrCnt[4] = 3;
 268   4      //                                      }
 269   4      //                                      if(Cmd.bSensorErrCnt[5] >= 3)
 270   4      //                                      {
 271   4      //                                              Cmd.bSensorErrCnt[5] = 3;
 272   4      //                                      }
 273   4      
 274   4                                              Cmd_NextSensorDet(FALSE);
 275   4                                      }
 276   3                                      break;
 277   3                              }
 278   2      
 279   2                              case MST_SEND_DISTANCE_TO_BCM:
 280   2                              {
 281   3                                      if(Cmd.wWaitTime > 100)
 282   3                                      {
 283   4                                              Cmd_UpdataDistance();
 284   4                                              CommunicaitonMode(COM_Internal);
 285   4                                              InitUart0ReceiveVar();
 286   4                                              Cmd_SendDistancetoBCM();
 287   4      
 288   4                                              if(Cmd.bUsedSnrNUM  == 5)
 289   4                                              {
 290   5                                                      Cmd.wWaitTime = 92;//50;
 291   5                                              }
 292   4                                              else if(Cmd.bUsedSnrNUM  == 3)
 293   4                                              {
 294   5                                                      Cmd.wWaitTime = 92;//50;
 295   5                                              }
 296   4                                      }
 297   3                                      if(Cmd.wWaitTime > 0 && Cmd.wWaitTime < 93)
 298   3                                      {
 299   4      
 300   4      #if(TEST_CODE_VEHICLE == TRUE)
              {
                      Uart0RX_OK_Flag = Rec_VechiInfo;
                      MsgBCM_Info._bit.ReversGearSts = TRUE;
C51 COMPILER V9.60.0.0   COMMAND                                                           08/08/2020 16:35:49 PAGE 6   

              }
              #endif
 306   4                          /*
 307   4                                              if(Cmd_RenewVechileCfg() == TRUE)
 308   4                                              {
 309   4                                                      Cmd.Debug_bVechInfoOKCnt++;
 310   4                                                      Cmd_NextSensorDet(TRUE);
 311   4                                                      Cmd.wWaitTime = 110;
 312   4      
 313   4      //                                              //TEST
 314   4      //                                              Cmd.CmdStatus = MST_SEND_DISTANCE_TO_BCM;
 315   4                                              }
 316   4                                              */
 317   4                                              Cmd.wWaitTime--;
 318   4                                      }
 319   3                                      else if(Cmd.wWaitTime == 0)
 320   3                                      {
 321   4                                              Cmd.Debug_bVechInfoErrCnt++;
 322   4                                              //if(++Cmd.bVechInfoErrCnt > SENSOR_EER_THRE_CAR)
 323   4                                              if(++Cmd.bVechInfoErrCnt > 5)
 324   4                                              {
 325   5                                                      Cmd.bVechInfoErrCnt = SENSOR_EER_THRE_CAR;
 326   5                                                      DetObj_InitAllChannelDistance();
 327   5                                                      Cmd_UpdataDistance();
 328   5                                                      Cmd.bID = ID_RL;
 329   5                                              }
 330   4                                              Cmd.CmdStatus = MST_SEND_DISTANCE_TO_BCM;
 331   4                                              Cmd.wWaitTime = 110;
 332   4                                      }
 333   3      //                              else
 334   3      //                              {
 335   3      //                                      Cmd.wWaitTime = 110;
 336   3      //                              }
 337   3      
 338   3      
 339   3      
 340   3                                      //test
 341   3      //              #if(TEST_CODE_VEHICLE == TRUE)
 342   3      //              {
 343   3      //              Uart0RX_OK_Flag = Rec_VechiInfo;
 344   3      //              MsgBCM_Info._bit.ReversGearSts = TRUE;
 345   3      //              }
 346   3      //              #endif
 347   3      //                      if(Cmd_RenewVechileCfg() == TRUE)
 348   3      //                      {
 349   3      //                              Cmd.Debug_bVechInfoOKCnt++;
 350   3      //                              Cmd_NextSensorDet(TRUE);
 351   3      //                              Cmd.wWaitTime = 110;
 352   3      //                      }
 353   3      
 354   3                                      break;
 355   3                              }
 356   2                              case MST_WAIT_VECHILE_CFG:
 357   2                              {
 358   3      #if(TEST_CODE_VEHICLE == TRUE)
              {
                      Uart0RX_OK_Flag = Rec_VechiInfo;
                      MsgBCM_Info._bit.ReversGearSts = TRUE;
              }
              #endif
 364   3                                      if(Cmd.wWaitTime > 0)
 365   3                                      {
 366   4                                              /*
C51 COMPILER V9.60.0.0   COMMAND                                                           08/08/2020 16:35:49 PAGE 7   

 367   4                                              if(Cmd_RenewVechileCfg() == TRUE)
 368   4                                              {
 369   4                                                      InitUart0ReceiveVar();
 370   4                                                      Cmd_NextSensorDet(TRUE);
 371   4                                              }
 372   4                                              */
 373   4                                              Cmd.wWaitTime--;
 374   4                                      }
 375   3                                      else
 376   3                                      {
 377   4                                              InitUart0ReceiveVar();
 378   4                                              if(++Cmd.bVechInfoErrCnt > SENSOR_EER_THRE_CAR)
 379   4                                              {
 380   5                                                      Cmd.bVechInfoErrCnt = SENSOR_EER_THRE_CAR;
 381   5      //                                              Cmd_ClearBuffer();
 382   5                                                      DetObj_InitAllChannelDistance();
 383   5                                                      Cmd_UpdataDistance();
 384   5                                                      Cmd.bID = ID_RL;
 385   5                                                      Cmd.CmdStatus = MST_SEND_DISTANCE_TO_BCM;
 386   5                                              }
 387   4                                      }
 388   3                                      break;
 389   3                              }
 390   2      
 391   2                              case CMD_STOP:
 392   2                              {
 393   3      #if(TEST_CODE_VEHICLE == TRUE)
              {
                      Uart0RX_OK_Flag = Rec_VechiInfo;
                      MsgBCM_Info._bit.ReversGearSts = TRUE;
              }
              #endif
 399   3                                      if(Cmd.wWaitTime > 0)
 400   3                                      {
 401   4                                              /*
 402   4                                              if(Cmd_RenewVechileCfg() == TRUE)
 403   4                                              {
 404   4                                                      Cmd_NextSensorDet(TRUE);
 405   4                                              }
 406   4                                              */
 407   4                                              Cmd.wWaitTime--;
 408   4                                      }
 409   3                                      else
 410   3                                      {
 411   4                                              DetObj_InitAllChannelDistance();
 412   4                                              Cmd_UpdataDistance();
 413   4                                              CommunicaitonMode(COM_Internal);
 414   4                                              Cmd_SendDistancetoBCM();
 415   4                                              Cmd.wWaitTime = SENSOR_STOP_SCAN_TIME;
 416   4                                      }
 417   3                                      break;
 418   3                              }
 419   2      
 420   2                              case SLV_WAIT_CMD:
 421   2                              {
 422   3                                      if(Serial.CmdHead_Rx == CMD_HEAD_800)   //work command head
 423   3                                      {
 424   4                                              if(Serial.bValid == TRUE)
 425   4                                              {
 426   5                                                      Serial.bValid = FALSE;
 427   5      
 428   5      //                                              test
 429   5      //                                              if((Serial.byData&0x07) == 0)
C51 COMPILER V9.60.0.0   COMMAND                                                           08/08/2020 16:35:49 PAGE 8   

 430   5      //                                              {
 431   5      //                                                      Cmd.wWaitTime = 0;
 432   5      //                                              }
 433   5      //                                              if((Serial.byData&0x07) == 1)
 434   5      //                                              {
 435   5      //                                                      Cmd.wWaitTime = 1;
 436   5      //                                              }
 437   5      //                                              if((Serial.byData&0x07) == 2)
 438   5      //                                              {
 439   5      //                                                      Cmd.wWaitTime = 2;
 440   5      //                                              }
 441   5      //                                              if((Serial.byData&0x07) == 3)
 442   5      //                                              {
 443   5      //                                                      Cmd.wWaitTime = 3;
 444   5      //                                              }
 445   5      //                                              if((Serial.byData&0x07) == 4)
 446   5      //                                              {
 447   5      //                                                      Cmd.wWaitTime = 4;
 448   5      //                                              }
 449   5      //                                              if((Serial.byData&0x07) == 5)
 450   5      //                                              {
 451   5      //                                                      Cmd.wWaitTime = 5;
 452   5      //                                              }
 453   5      //                                              if((Serial.byData&0x07) == 6)
 454   5      //                                              {
 455   5      //                                                      Cmd.wWaitTime = 6;
 456   5      //                                              }
 457   5      
 458   5                                                      if((Serial.byData&0x07) == DetInfo.bID)
 459   5                                                      {
 460   6                                                              Cmd.wWaitTime = SINGLE_SENSOR_TIME_OVER_MAX;
 461   6                                                              DetInfo.bDetTriggerFlag = TRUE;
 462   6                                                              CommunicaitonMode(NO_Com);
 463   6                                                              Cmd.CmdStatus = SLV_DISTANCE_BACK;
 464   6                                                      }
 465   5                                              }
 466   4                                      }
 467   3      
 468   3                                      if(Serial.CmdHead_Rx == CMD_HEAD_3000)  //Work frock command head
 469   3                                      {
 470   4                                              if(Serial.bValid == TRUE)
 471   4                                              {
 472   5                                                      Serial.bValid = FALSE;
 473   5                                                      CommunicaitonMode(COM_Internal);
 474   5                                                      Cmd.CmdStatus = SLV_CALIBRATION;
 475   5                                              }
 476   4                                      }
 477   3      
 478   3                                      if(Serial.CmdHead_Rx == CMD_HEAD_2500)    //Self check command head
 479   3                                      {
 480   4                                              if(Serial.bValid == TRUE)
 481   4                                              {
 482   5                                                      Serial.bValid = FALSE;
 483   5                                                      if((Serial.byData&0x07) == DetInfo.bID)
 484   5                                                      {
 485   6                                                              Cmd.wWaitTime = SINGLE_SENSOR_TIME_OVER_MAX;
 486   6                                                              DetInfo.bDetTriggerFlag = FALSE;
 487   6                                                              CommunicaitonMode(COM_Internal);
 488   6                                                              Cmd.CmdStatus = SLV_DISTANCE_BACK;
 489   6                                                      }
 490   5                                              }
 491   4                                      }
 492   3      
C51 COMPILER V9.60.0.0   COMMAND                                                           08/08/2020 16:35:49 PAGE 9   

 493   3                                      break;
 494   3                              }
 495   2      
 496   2                              case SLV_DISTANCE_BACK:
 497   2                              {
 498   3      #if(TEST_CODE_DETDATA == TRUE)
              {
                      NearestData.bNearestDistance          = 0x20;
                      DiagInfo.bSelfCheckResult[DetInfo.bID] = 0;             //0-OK,1-NG
                      DiagInfo.bKeepFlag                     = 0;
              }
              #endif
 505   3      
 506   3      //                              CommunicaitonMode(COM_Internal);
 507   3                                      Cmd.wBackData =(((WORD)NearestData.bNearestDistance)|
 508   3                                                              ((WORD)DiagInfo.bSelfCheckResult[DetInfo.bID]<<8)|
 509   3                                                                      ((WORD)DiagInfo.bKeepFlag<<9));
 510   3                                      Srl_SendData(HEAD_1000, DetInfo.bID, ID_LEN_BIT, Cmd.wBackData, 10);
 511   3                                      CommunicaitonMode(COM_Internal);
 512   3                                      Cmd.CmdStatus = SLV_WAIT_CMD;
 513   3                                      break;
 514   3                              }
 515   2      
 516   2                              case SLV_CALIBRATION:
 517   2                              {
 518   3                                      if(Serial.CmdHead_Rx == CMD_HEAD_3000)
 519   3                                      {
 520   4                                              if(Serial.bValid == TRUE)
 521   4                                              {
 522   5                                                      Serial.bValid = FALSE;
 523   5                                                      Cmd.CmdCalibration = (Serial.byData&0xF);
 524   5                                                      DetInfo.bDetTriggerFlag = TRUE;
 525   5                                                      Stop_PCA0_Capture(0);           //DATA
 526   5                                                      Cmd.CmdStatus = SLV_CALIBRATION_BACK;
 527   5                                              }
 528   4                                      }
 529   3                                      break;
 530   3                              }
 531   2      
 532   2                              case SLV_CALIBRATION_BACK:
 533   2                              {
 534   3                                      switch(Cmd.CmdCalibration)
 535   3                                      {
 536   4                                              case CMD_REQUEST_DISTANCE :     Cmd.wBackData = ClrtData.bDistance;             break;
 537   4                                              case CMD_REQUEST_RINGTIME :             Cmd.wBackData = (ClrtData.wRingTime/10);                break;
 538   4                                              case CMD_REQUEST_ECHO_WIDTH     :       Cmd.wBackData = ClrtData.wTimeWidth;    break;
 539   4                                              case CMD_REQUEST_ECHO_VOL :             Cmd.wBackData = ClrtData.bVolHeight;    break;
 540   4                                              case CMD_REQUEST_SOFTWARE_VERSION :             Cmd.wBackData = 0x01;                   break;
 541   4                                              case CMD_REQUEST_HARDWARE_VERSION :             Cmd.wBackData = 0x01;                   break;
 542   4                                              case CMD_REQUEST_ID                :
 543   4                                                      Cmd.wBackData = DetInfo.bID;
 544   4                                                      break;
 545   4                                              default:
 546   4                                                      Cmd.wBackData = 0x00;
 547   4                                      }
 548   3                                      Srl_SendData(HEAD_3000, Cmd.CmdCalibration, TEST_CMD_LEN_BIT, Cmd.wBackData, 8);
 549   3                                      Start_PCA0_Capture(0);          //DATA
 550   3                                      Cmd.CmdStatus = SLV_CALIBRATION;
 551   3                                      break;
 552   3                              }
 553   2      
 554   2                              case DEBUG_MODE:
 555   2                              {
C51 COMPILER V9.60.0.0   COMMAND                                                           08/08/2020 16:35:49 PAGE 10  

 556   3      #if(TEST_CODE_VEHICLE == TRUE)
              {
                      Uart0RX_OK_Flag = Rec_VechiInfo;
                      MsgBCM_Info._bit.ReversGearSts = TRUE;
              }
              #endif
 562   3                                      if(Cmd.wWaitTime > 0)
 563   3                                      {
 564   4                                          /*
 565   4                                              if(Cmd_RenewVechileCfg() == TRUE)
 566   4                                              {
 567   4                                                      Cmd.CmdStatus = DEBUG_MODE;
 568   4                                                      Cmd.wWaitTime = 1;
 569   4                                              }
 570   4                                              */
 571   4                                              Cmd.wWaitTime--;
 572   4                                      }
 573   3                                      else
 574   3                                      {
 575   4                                              DetObj_InitAllChannelDistance();
 576   4                                              Cmd_UpdataDistance();
 577   4                                              CommunicaitonMode(COM_Internal);
 578   4                                              Cmd_SendDistancetoBCM();
 579   4                                              Cmd.wWaitTime = SENSOR_STOP_SCAN_TIME;
 580   4                                      }
 581   3                                      break;
 582   3                              }
 583   2      
 584   2      
 585   2                              default:
 586   2                              ;
 587   2                      }
 588   1      
 589   1      
 590   1      
 591   1      
 592   1      }
 593          
 594          void Cmd_SaveData(void)
 595          {
 596   1              if(Cmd.bID != ID_MASTER)
 597   1              {
 598   2                      if(((Serial.byData >> 11) & 0x01) == 0x00) //The self-test data are normal; 1 is error
 599   2                      {
 600   3                              //if(((Serial.byData >> 12) & 0x01) == 0x00) //Determine whether the sensor keep or not; 1 is keep
 601   3                              DiagInfo.bSelfCheckResult[Cmd.bID] = 0;
 602   3                              NearestData.bEachNearestDistance[Cmd.bID] = (BYTE)(Serial.byData >> 3);
 603   3                      }
 604   2                      else
 605   2                      {
 606   3                              DiagInfo.bSelfCheckResult[Cmd.bID] = 0;
 607   3                              NearestData.bEachNearestDistance[Cmd.bID] = 0xFF;
 608   3                      }
 609   2              }
 610   1              Serial.byData = (WORD)0x0000;
 611   1      }
 612          
 613          void Cmd_UpdataDistance(void)
 614          {
 615   1              Cmd_DistancetoComInfo();
 616   1      
 617   1              MsgRadar_Distance._bit.RPADetectionRL = Cmd.bDistance[ID_RL];
 618   1              MsgRadar_Distance._bit.RPADetectionRML = Cmd.bDistance[ID_RML];
C51 COMPILER V9.60.0.0   COMMAND                                                           08/08/2020 16:35:49 PAGE 11  

 619   1              MsgRadar_Distance._bit.RPADetectionRMR = 0x00;
 620   1              MsgRadar_Distance._bit.RPADetectionRR = 0x00;
 621   1              MsgRadar_Distance._bit.RPADetectionFL = 0x00;
 622   1              MsgRadar_Distance._bit.RPADetectionFR = 0x00;
 623   1      
 624   1              MsgRadar_Distance._bit.ObsorientRL = Cmd.bObsorient[ID_RL];
 625   1              MsgRadar_Distance._bit.ObsorientRML = Cmd.bObsorient[ID_RML];
 626   1              MsgRadar_Distance._bit.ObsorientRMR = 0x00;
 627   1              MsgRadar_Distance._bit.ObsorientRR = 0x00;
 628   1              MsgRadar_Distance._bit.ObsorientFL = 0x00;
 629   1              MsgRadar_Distance._bit.ObsorientFR = 0x00;
 630   1              MsgRadar_Distance._bit.Reserve = 0x00;
 631   1      
 632   1              MsgRadar_Distance._bit.RPASpeakerInfo = Cmd.bBuzzerInfo;
 633   1      }
 634          
 635          void Cmd_DistancetoComInfo(void)
 636          {
 637   1              BYTE i;
 638   1              BYTE NearestDis;
 639   1              NearestDis = 0xFF;
 640   1      
 641   1              for(i=0;i<ID_SUM;i++)                                   //distance value cale to command data
 642   1              {
 643   2                      if((NearestData.bEachNearestDistance[i] < 30) &&
 644   2                         (NearestData.bEachNearestDistance[i] > 0) )
 645   2                      {
 646   3                              Cmd.bDistance[i] = 1;
 647   3                      }
 648   2                      else if(NearestData.bEachNearestDistance[i]<MAX_DETECT_DISTANCE)
 649   2                      {
 650   3                              Cmd.bDistance[i] = (NearestData.bEachNearestDistance[i]-20)/10;
 651   3                      }
 652   2                      else if(NearestData.bEachNearestDistance[i] == MAX_DETECT_DISTANCE)
 653   2                      {
 654   3                              Cmd.bDistance[i] = 0x0C;
 655   3                      }
 656   2                      else
 657   2                      {
 658   3                              Cmd.bDistance[i] = 0;
 659   3                      }
 660   2      
 661   2                      if(Cmd.bDistance[i] == 0)               //set the orient
 662   2                      {
 663   3                              Cmd.bObsorient[i] = 0;
 664   3                      }
 665   2                      else
 666   2                      {
 667   3                              Cmd.bObsorient[i] = 1;
 668   3                      }
 669   2              }
 670   1      
 671   1              if(Cmd.bUsedSnrNUM  == 5)
 672   1              {
 673   2                      if(Cmd.bDistance[ID_RL] > 5)
 674   2                      {
 675   3                              Cmd.bDistance[ID_RL] = 0;
 676   3                      }
 677   2                      if(Cmd.bDistance[ID_RML] > 9)
 678   2                      {
 679   3                              Cmd.bDistance[ID_RML] = 0;
 680   3                      }
 681   2                      /*
C51 COMPILER V9.60.0.0   COMMAND                                                           08/08/2020 16:35:49 PAGE 12  

 682   2                      if(Cmd.bDistance[ID_RR] > 5)
 683   2                      {
 684   2                              Cmd.bDistance[ID_RR] = 0;
 685   2                      }
 686   2                      if(Cmd.bDistance[ID_FL] > 5)
 687   2                      {
 688   2                              Cmd.bDistance[ID_FL] = 0;
 689   2                      }
 690   2                      if(Cmd.bDistance[ID_FR] > 5)
 691   2                      {
 692   2                              Cmd.bDistance[ID_FR] = 0;
 693   2                      }
 694   2                      */
 695   2                      for(i=0;i<ID_SUM;i++)
 696   2                      {
 697   3                              if(NearestData.bEachNearestDistance[i] > EachSNMaxDistance_5Snr[i])
 698   3                              {
 699   4                                      NearestData.bEachNearestDistance[i] = 0xFF;
 700   4                              }
 701   3                              if(NearestDis > NearestData.bEachNearestDistance[i])
 702   3                              {
 703   4                                      NearestDis = NearestData.bEachNearestDistance[i];
 704   4                              }
 705   3                      }
 706   2                      if(NearestDis > SN_DISTANCE_5Snr_RML)                   //renew the buzzer information
 707   2                      {
 708   3                              Cmd.bBuzzerInfo = 0;
 709   3                      }
 710   2                      else if(NearestDis >= MID_DETECT_DISTANCE)
 711   2                      {
 712   3                              Cmd.bBuzzerInfo = 2;
 713   3                      }
 714   2                      else if(NearestDis >= CONTINUOUS_CHIME_DISTANCE)
 715   2                      {
 716   3                              Cmd.bBuzzerInfo = 4;
 717   3                      }
 718   2                      else if(NearestDis >= 0)
 719   2                      {
 720   3                              Cmd.bBuzzerInfo = 7;
 721   3                      }
 722   2              }
 723   1              else if(Cmd.bUsedSnrNUM  == 2)
 724   1              {
 725   2                      if(Cmd.bDistance[ID_RL] > 0x0C)
 726   2                      {
 727   3                              Cmd.bDistance[ID_RL] = 0;
 728   3                      }
 729   2                      if(Cmd.bDistance[ID_RML] > 0x0C)
 730   2                      {
 731   3                              Cmd.bDistance[ID_RML] = 0;
 732   3                      }
 733   2                      /*
 734   2                      if(Cmd.bDistance[ID_RR] > 7)
 735   2                      {
 736   2                              Cmd.bDistance[ID_RR] = 0;
 737   2                      }
 738   2                      Cmd.bDistance[ID_FL] = 0;
 739   2                      Cmd.bDistance[ID_FR] = 0;
 740   2                      */
 741   2                      for(i=0;i<ID_SUM;i++)
 742   2                      {
 743   3                              if(NearestData.bEachNearestDistance[i] > EachSNMaxDistance_2Snr[i])
 744   3                              {
C51 COMPILER V9.60.0.0   COMMAND                                                           08/08/2020 16:35:49 PAGE 13  

 745   4                                      NearestData.bEachNearestDistance[i] = 0xFF;
 746   4                              }
 747   3      
 748   3                              if(NearestDis > NearestData.bEachNearestDistance[i])
 749   3                              {
 750   4                                      NearestDis = NearestData.bEachNearestDistance[i];
 751   4                              }
 752   3                      }
 753   2                      if(NearestDis > SN_DISTANCE_2Snr_RML)                   //renew the buzzer information
 754   2                      {
 755   3                              Cmd.bBuzzerInfo = 3;
 756   3                      }
 757   2                      else if(NearestDis >= MID_DETECT_DISTANCE)
 758   2                      {
 759   3                              Cmd.bBuzzerInfo = 2;
 760   3                      }
 761   2                      else if(NearestDis >= CONTINUOUS_CHIME_DISTANCE)
 762   2                      {
 763   3                              Cmd.bBuzzerInfo = 1;
 764   3                      }
 765   2                      else if(NearestDis >= 0)
 766   2                      {
 767   3                              Cmd.bBuzzerInfo = 0;
 768   3                      }
 769   2              }
 770   1      }
 771          
 772          void Cmd_NextSensorSelf(void)
 773          {
 774   1          Cmd.CmdStatus = MST_DRV_SENSOR_SELFCHECK;
 775   1          Cmd.bID++;
 776   1          if(Cmd.bID == ID_MASTER)Cmd.bID++;
 777   1          if(Cmd.bID == ID_SUM)
 778   1          {
 779   2              Cmd.bID = ID_RL;
 780   2          }
 781   1              /*
 782   1          if(Cmd.bID > (Cmd.bUsedSnrNUM+1))
 783   1          {
 784   1              Cmd.bID = ID_RL;
 785   1              Cmd.CmdStatus = MST_SEND_SELF_TO_BCM;
 786   1          }
 787   1          */
 788   1      }
 789          
 790          void Cmd_NextSensorDet(BYTE ForceCutFlag)
 791          {
 792   1              BYTE cnt,sta;
 793   1              BYTE forcecutflag_b;
 794   1      
 795   1              cnt = 0;
 796   1              sta = FALSE;
 797   1              forcecutflag_b = ForceCutFlag;
 798   1              if(forcecutflag_b == TRUE)
 799   1              {
 800   2                      for(cnt=0;cnt<(Cmd.bUsedSnrNUM+1);cnt++)
 801   2                      {
 802   3                              Cmd.bID++;
 803   3                              Cmd.bID = Cmd.bID % (Cmd.bUsedSnrNUM+1);
 804   3                          if(Cmd.bID == ID_SUM)
 805   3                          {
 806   4                              Cmd.bID = ID_RL;
 807   4                          }
C51 COMPILER V9.60.0.0   COMMAND                                                           08/08/2020 16:35:49 PAGE 14  

 808   3                              if(Cmd.bSensorRun[Cmd.bID] == TRUE)
 809   3                              {
 810   4                                      sta = TRUE;
 811   4                                      break;
 812   4                              }
 813   3                      }
 814   2                      if(sta)
 815   2                      {
 816   3                              if(Cmd.bID == ID_MASTER)
 817   3                              {
 818   4                                      DetInfo.bDetTriggerFlag = TRUE;
 819   4                              }
 820   3                              CommunicaitonMode(COM_Internal);
 821   3                              Cmd.CmdStatus = MST_DRV_SENSOR;
 822   3                      }
 823   2              }
 824   1              else
 825   1              {
 826   2                      if(Cmd.bID == ID_RML)
 827   2                      {
 828   3                              Cmd.CmdStatus = MST_SEND_DISTANCE_TO_BCM;
 829   3                              Cmd.wWaitTime = 110;
 830   3                      }
 831   2                      else
 832   2                      {
 833   3                              for(cnt=0;cnt<(Cmd.bUsedSnrNUM+1);cnt++)
 834   3                              {
 835   4                                      Cmd.bID++;
 836   4                                      Cmd.bID = Cmd.bID % (Cmd.bUsedSnrNUM+1);
 837   4                                  if(Cmd.bID == ID_SUM)
 838   4                                  {
 839   5                                      Cmd.bID = ID_RL;
 840   5                                  }
 841   4                                      if(Cmd.bSensorRun[Cmd.bID] == TRUE)
 842   4                                      {
 843   5                                              sta = TRUE;
 844   5                                              break;
 845   5                                      }
 846   4                              }
 847   3                              if(cnt == (Cmd.bUsedSnrNUM+1))                  //debug watch
 848   3                              {
 849   4      //                              Cmd.CmdStatus = CMD_STOP;
 850   4                                      Cmd_ClearBuffer();
 851   4                                      sta = FALSE;
 852   4                              }
 853   3                              if(sta)
 854   3                              {
 855   4                                  if(Cmd.bID == ID_MASTER)
 856   4                                  {
 857   5                                      DetInfo.bDetTriggerFlag = TRUE;
 858   5                                  }
 859   4                                  CommunicaitonMode(COM_Internal);
 860   4                                  Cmd.CmdStatus = MST_DRV_SENSOR;
 861   4                              }
 862   3                      }
 863   2              }
 864   1      }
 865          
 866          void Cmd_ClearBuffer(void)
 867          {
 868   1          BYTE i;
 869   1          for(i=0; i<SN_NUM; i++)
 870   1          {
C51 COMPILER V9.60.0.0   COMMAND                                                           08/08/2020 16:35:49 PAGE 15  

 871   2                NearestData.bEachNearestDistance[i] = 0xFF;
 872   2          }
 873   1      }
 874          
 875          void Cmd_SendReqVechiModetoBCM(void)
 876          {
 877   1              BYTE i;
 878   1      
 879   1              UART0_ModeDataL();
 880   1              UART0_INTRX_Dis();
 881   1              Delay1us(START_UART_DELAY);
 882   1      
 883   1              for(i=0;i<5;i++)
 884   1              {
 885   2                      UART0_WriteByte(MsgRadar_ReqMode._Word[i]);
 886   2              }
 887   1              Delay1us(END_UART_DELAY);
 888   1              UART0_INTRX_En();
 889   1              UART0_ModeDataH();
 890   1      }
 891          
 892          void Cmd_SendSelfChecktoBCM(void)
 893          {
 894   1      
 895   1      /*
 896   1              BYTE i,eve_temp;
 897   1          WORD checksum_temp;
 898   1      
 899   1          checksum_temp = CalcFrameChecksum(UART0_FRM_SENDSELF);
 900   1          MsgRadar_Self._Byte[3] = checksum_temp;
 901   1              for(i=0;i<4;i++)
 902   1              {
 903   1                      eve_temp = CalcByteEVEN(MsgRadar_Self._Byte[i]);
 904   1                      MsgRadar_Self._Byte[i] |= (WORD)((eve_temp & 0x01) << 8);
 905   1              }
 906   1      
 907   1              UART0_ModeDataL();
 908   1              UART0_INTRX_Dis();
 909   1              Delay1us(START_UART_DELAY);
 910   1      
 911   1          for(i=0;i<5;i++)
 912   1          {
 913   1              UART0_WriteByte(MsgRadar_Self._Byte[i]);
 914   1          }
 915   1      */
 916   1              WORD  eve_temp;
 917   1              eve_temp = MsgRadar_Self._bit.SelfCheck_EVEN; 
 918   1              if (eve_temp == 0x0000)
 919   1                      {
 920   2                      Srl_SendData(HEAD_2000,Cmd.bID,ID_LEN_BIT,0xF000,6);
 921   2                      }else
 922   1                      {
 923   2                      Srl_SendData(HEAD_2000,Cmd.bID,ID_LEN_BIT,0xFC00,6);
 924   2                      }
 925   1      
 926   1          //Delay1us(END_UART_DELAY);
 927   1      //      UART0_INTRX_En();    //MP5
 928   1              //UART0_ModeDataH();
 929   1      }
 930          
 931          void Cmd_SendDistancetoBCM(void)
 932          {
 933   1      /*
C51 COMPILER V9.60.0.0   COMMAND                                                           08/08/2020 16:35:49 PAGE 16  

 934   1              BYTE i,eve_temp;
 935   1          WORD checksum_temp;
 936   1      //TEST
 937   1      //      MsgRadar_Distance._bit.RPADetectionRL = 1;
 938   1      //      MsgRadar_Distance._bit.RPADetectionRML = 3;
 939   1      //      MsgRadar_Distance._bit.RPADetectionRR = 9;
 940   1      //      MsgRadar_Distance._bit.RPADetectionFL = 1;
 941   1      //      MsgRadar_Distance._bit.RPADetectionFR = 3;
 942   1      //
 943   1      //      MsgRadar_Distance._bit.ObsorientRL = 1;
 944   1      //      MsgRadar_Distance._bit.ObsorientRML = 1;
 945   1      //      MsgRadar_Distance._bit.ObsorientRR = 1;
 946   1      //      MsgRadar_Distance._bit.ObsorientFL = 1;
 947   1      //      MsgRadar_Distance._bit.ObsorientFR = 1;
 948   1      
 949   1      //      MsgRadar_Distance._bit.RPASpeakerInfo = Cmd.bBuzzerInfo;
 950   1      
 951   1          checksum_temp = CalcFrameChecksum(UART0_FRM_DISTANCE);
 952   1          MsgRadar_Distance._Byte[7] = checksum_temp;
 953   1              for(i=0;i<8;i++)
 954   1              {
 955   1                      MsgRadar_Distance._Byte[i] &= 0x00FF;
 956   1                      eve_temp = CalcByteEVEN(MsgRadar_Distance._Byte[i]);
 957   1                      MsgRadar_Distance._Byte[i] |= (WORD)((eve_temp & 0x01) << 8);
 958   1              }
 959   1      
 960   1              Uart0TX_ALL_Flag = FALSE;
 961   1              UART0_ModeDataL();
 962   1              UART0_INTRX_Dis();
 963   1              //The delay time need to adjust
 964   1              Delay1us(START_UART_DELAY);
 965   1          for(i=0;i<9;i++)
 966   1          {
 967   1              UART0_WriteByte(MsgRadar_Distance._Byte[i]);
 968   1          }
 969   1      */
 970   1          WORD  eve_temp;
 971   1      
 972   1              eve_temp = MsgRadar_Distance._bit.RPASpeakerInfo;
 973   1      
 974   1              Srl_SendData(HEAD_1500,Cmd.bID,ID_LEN_BIT,0xFFFF,16);
 975   1              if(eve_temp == 0x0000)
 976   1                      {
 977   2                      Srl_SendData(HEAD_1500,Cmd.bID,ID_LEN_BIT,0x0000,3);
 978   2                      }else if (eve_temp == 0x0001)
 979   1                      {
 980   2                      Srl_SendData(HEAD_1500,Cmd.bID,ID_LEN_BIT,0xA000,3);
 981   2                      }else if (eve_temp == 0x0002)
 982   1                      {
 983   2                      Srl_SendData(HEAD_1500,Cmd.bID,ID_LEN_BIT,0x6000,3);
 984   2                      }else
 985   1                      {
 986   2                      Srl_SendData(HEAD_1500,Cmd.bID,ID_LEN_BIT,0xC000,3);
 987   2                      }
 988   1          //Delay1us(END_UART_DELAY);
 989   1              //UART0_INTRX_En();
 990   1              //UART0_ModeDataH();
 991   1      
 992   1      
 993   1      }
 994          
 995          BYTE Cmd_VechileCfgCheck(void)
 996          {
C51 COMPILER V9.60.0.0   COMMAND                                                           08/08/2020 16:35:49 PAGE 17  

 997   1      
 998   1      
 999   1              return FALSE;
1000   1      }
1001          
1002          #if 0
              BYTE Cmd_RenewVechileCfg(void)
              {
                      if(Uart0RX_OK_Flag == Rec_VechiInfo)
                      {
                              Cmd.bVechInfoErrCnt = 0;
                              Uart0RX_OK_Flag = Rec_ERR;
              
                              if(Cmd.bUsedSnrNUM  == 5)
                              {
                                      if(MsgBCM_Info._bit.ReversGearSts == TRUE)
                                      {
                                              Cmd.bSensorRun[ID_RL]   = TRUE;
                                              Cmd.bSensorRun[ID_RML]  = TRUE;
                                              Cmd.bSensorRun[ID_RR]   = TRUE;
                                              Cmd.bSensorRun[ID_FL]   = TRUE;
                                              Cmd.bSensorRun[ID_FR]   = TRUE;
                                              return TRUE;
                                      }
                                      else if(MsgBCM_Info._bit.ParkingGearSts == TRUE)
                                      {
                                              Cmd.bSensorRun[ID_RL]   = FALSE;
                                              Cmd.bSensorRun[ID_RML]  = FALSE;
                                              Cmd.bSensorRun[ID_RR]   = FALSE;
                                              Cmd.bSensorRun[ID_FL]   = FALSE;
                                              Cmd.bSensorRun[ID_FR]   = FALSE;
              
                                              NearestData.bEachNearestDistance[ID_RL]   = 0XFF;
                                              NearestData.bEachNearestDistance[ID_RML]  = 0XFF;
                                              NearestData.bEachNearestDistance[ID_RR]   = 0XFF;
                                              NearestData.bEachNearestDistance[ID_FL]   = 0XFF;
                                              NearestData.bEachNearestDistance[ID_FR]   = 0XFF;
              
                                      }
                                      else if((MsgBCM_Info._bit.FrontSwitchSts == TRUE) &&
                                                      (MsgBCM_Info._bit.VehicleSpeed   == FALSE))
                                      {
                                              Cmd.bSensorRun[ID_RL]   = TRUE;
                                              Cmd.bSensorRun[ID_RML]  = TRUE;
                                              Cmd.bSensorRun[ID_RR]   = TRUE;
                                              Cmd.bSensorRun[ID_FL]   = TRUE;
                                              Cmd.bSensorRun[ID_FR]   = TRUE;
                                              return TRUE;
              
                                      }
                                      else
                                      {
                                              Cmd.bSensorRun[ID_RL]   = FALSE;
                                              Cmd.bSensorRun[ID_RML]  = FALSE;
                                              Cmd.bSensorRun[ID_RR]   = FALSE;
                                              Cmd.bSensorRun[ID_FL]   = FALSE;
                                              Cmd.bSensorRun[ID_FR]   = FALSE;
              
                                              NearestData.bEachNearestDistance[ID_RL]   = 0XFF;
                                              NearestData.bEachNearestDistance[ID_RML]  = 0XFF;
                                              NearestData.bEachNearestDistance[ID_RR]   = 0XFF;
                                              NearestData.bEachNearestDistance[ID_FL]   = 0XFF;
                                              NearestData.bEachNearestDistance[ID_FR]   = 0XFF;
C51 COMPILER V9.60.0.0   COMMAND                                                           08/08/2020 16:35:49 PAGE 18  

                                      }
                              }
                              else if(Cmd.bUsedSnrNUM  == 3)
                              {
                                      if(MsgBCM_Info._bit.ReversGearSts == TRUE)
                                      {
                                              Cmd.bSensorRun[ID_RL]   = TRUE;
                                              Cmd.bSensorRun[ID_RML]  = TRUE;
                                              Cmd.bSensorRun[ID_RR]   = TRUE;
                                              Cmd.bSensorRun[ID_FL]   = FALSE;
                                              Cmd.bSensorRun[ID_FR]   = FALSE;
                                              NearestData.bEachNearestDistance[ID_FL]   = 0XFF;
                                              NearestData.bEachNearestDistance[ID_FR]   = 0XFF;
                                              return TRUE;
                                      }
                                      else
                                      {
                                              Cmd.bSensorRun[ID_RL]   = FALSE;
                                              Cmd.bSensorRun[ID_RML]  = FALSE;
                                              Cmd.bSensorRun[ID_RR]   = FALSE;
                                              Cmd.bSensorRun[ID_FL]   = FALSE;
                                              Cmd.bSensorRun[ID_FR]   = FALSE;
              
                                              NearestData.bEachNearestDistance[ID_RL]   = 0XFF;
                                              NearestData.bEachNearestDistance[ID_RML]  = 0XFF;
                                              NearestData.bEachNearestDistance[ID_RR]   = 0XFF;
                                              NearestData.bEachNearestDistance[ID_FL]   = 0XFF;
                                              NearestData.bEachNearestDistance[ID_FR]   = 0XFF;
                                      }
                              }
                      }
                      return FALSE;
              
              
              
                      //test
              //      if(Uart0RX_OK_Flag == Rec_VechiInfo)
              //              {
              //                      Cmd.bVechInfoErrCnt = 0;
              //                      Uart0RX_OK_Flag = Rec_ERR;
              //                      //if(MsgBCM_Info._bit.ReversGearSts == TRUE)
              //                      {
              //                              Cmd.bSensorRun[ID_RL]   = TRUE;
              //                              Cmd.bSensorRun[ID_RML]  = TRUE;
              //                              Cmd.bSensorRun[ID_RR]   = TRUE;
              //                              Cmd.bSensorRun[ID_FL]   = TRUE;
              //                              Cmd.bSensorRun[ID_FR]   = TRUE;
              //                              return TRUE;
              //                      }
              //              }
              //      return FALSE;
              }
              
              #endif
1114          
1115          
1116          
1117          
1118          
1119          
1120          
1121          
1122          
C51 COMPILER V9.60.0.0   COMMAND                                                           08/08/2020 16:35:49 PAGE 19  

1123          
1124          
1125          
1126          
1127          
1128          
1129          
1130          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2717    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     45    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     12       8
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
