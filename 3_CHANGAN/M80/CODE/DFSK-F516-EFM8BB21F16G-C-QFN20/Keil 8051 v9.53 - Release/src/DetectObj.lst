C51 COMPILER V9.60.0.0   DETECTOBJ                                                         08/08/2020 16:35:49 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE DETECTOBJ
OBJECT MODULE PLACED IN .\src\DetectObj.OBJ
COMPILER INVOKED BY: c:\SiliconLabs\SimplicityStudio\v4\developer\toolchains\keil_8051\9.60\BIN\C51.exe C:\WorkSpace\3_C
                    -HAN\4_M80\1_CODE\DFSK-F516-EFM8BB21F16G-C-QFN20_20200107\src\DetectObj.c OMF2 SMALL DEBUG OBJECTEXTEND ROM(LARGE) WARNIN
                    -GLEVEL(2) FLOATFUZZY(3) OPTIMIZE(9,SPEED) DEFINE(NDEBUG=1) INTVECTOR(0X0000) INTPROMOTE INCDIR(C:\WorkSpace\3_CHAN\4_M80
                    -\1_CODE\DFSK-F516-EFM8BB21F16G-C-QFN20_20200107\inc;C:/SiliconLabs/SimplicityStudio/v4/developer/sdks/8051/v4.1.7//Devic
                    -e/shared/si8051base;C:/SiliconLabs/SimplicityStudio/v4/developer/sdks/8051/v4.1.7//Device/EFM8BB2/inc) REGFILE(DFSK-F516
                    --EFM8BB21F16G-C-QFN20_20200107.ORC) PRINT(.\src\DetectObj.lst) COND PAGEWIDTH(120) PAGELENGTH(65) OBJECT(.\src\DetectObj
                    -.OBJ)

line level    source

   1          /*********************************************************************************************************
             -************
   2          ** FILE NAME: DetectObj.c
   3          **
   4          ** PROJECT:  长城H2倒车雷达
   5          ** CPU:      EFM8BB21F16G
   6          ** COMPILER: 芯科
   7          ** -------------------------------------------------------------------------------------------------------
             -------------
   8          ** VERSION:  V1.0
   9          ** DATE:     2018.12.24
  10          **********************************************************************************************************
             -***********/
  11          
  12          #include "cpu.h"
  13          #include "DetectObj.h"
  14          #include "Timer.h"
  15          #include "ADC.h"
  16          #include "Command.h"
  17          #include "Serial.h"
  18          
  19          //********************************************************************************************************
             -*************
  20          //** Declear the global variable
  21          //********************************************************************************************************
             -*************/
  22          
  23          #define INTERVAL_LEN    6
  24          const BYTE  DetectInterval[INTERVAL_LEN] =
  25          {
  26           (1),(2),(4),(7),(3)
  27          };
  28          
  29          const BYTE      EachSNMaxDistance[SN_NUM] =
  30          {
  31            SN_DISTANCE_NULL,
  32            SN_DISTANCE_RL,
  33            SN_DISTANCE_RML,
  34            SN_DISTANCE_RR,
  35            SN_DISTANCE_FL,
  36            SN_DISTANCE_FR,
  37          };
  38          
  39          const BYTE      EachSNMaxDistance_5Snr[SN_NUM] =
  40          {
  41            SN_DISTANCE_5Snr_NULL,
  42            SN_DISTANCE_5Snr_RL,
  43            SN_DISTANCE_5Snr_RML,
  44            SN_DISTANCE_5Snr_RR,
  45            SN_DISTANCE_5Snr_FL,
C51 COMPILER V9.60.0.0   DETECTOBJ                                                         08/08/2020 16:35:49 PAGE 2   

  46            SN_DISTANCE_5Snr_FR,
  47          };
  48          const BYTE      EachSNMaxDistance_3Snr[SN_NUM] =
  49          {
  50            SN_DISTANCE_3Snr_NULL,
  51            SN_DISTANCE_3Snr_RL,
  52            SN_DISTANCE_3Snr_RML,
  53            SN_DISTANCE_3Snr_RR,
  54            SN_DISTANCE_3Snr_FL,
  55            SN_DISTANCE_3Snr_FR,
  56          };
  57            const BYTE  EachSNMaxDistance_2Snr[SN_NUM] =
  58            {
  59                  SN_DISTANCE_2Snr_RL,
  60                  SN_DISTANCE_2Snr_RML,
  61                  SN_DISTANCE_2Snr_RMR,
  62                  SN_DISTANCE_2Snr_RR,
  63                  SN_DISTANCE_2Snr_FL,
  64                  SN_DISTANCE_2Snr_FR,
  65            };
  66          
  67          
  68          StNearestData   xdata   NearestData;
  69          StDetInfo               xdata   DetInfo;
  70          StEchoRawData   xdata   RawData;
  71          StAnalysisData  xdata   AnsData;
  72          StCmpData               xdata   CmpData;
  73          StNoise                 xdata   Noise;
  74          StDiagInfo              xdata   DiagInfo;
  75          StCalibrationData xdata  ClrtData;
  76          CALLBACK                xdata   DetObj_DataPrcs;
  77          
  78          /*const*/ WORD  TableWidth[] =
  79          {
  80                300,/*    0cm     ~       8.7cm   */
  81                300,/*    8.7cm   ~       17.4cm  */
  82                300,/*    17.4cm  ~       26.1cm  */
  83                250,/*    26.1cm  ~       34.8cm  */
  84                200,/*    34.8cm  ~       43.5cm  */
  85                200,/*    43.5cm  ~       52.2cm  */
  86                200,/*    52.2cm  ~       60.9cm  */
  87                200,/*    60.9cm  ~       69.6cm  */
  88                200,/*    69.6cm  ~       78.3cm  */
  89                200,/*    78.3cm  ~       87.0cm  */
  90                200,/*    87.0cm  ~       95.7cm  */
  91                200,/*    95.7cm  ~       104.4cm */
  92                180,/*    104.4cm ~       113.1cm */
  93                180,/*    113.1cm ~       121.8cm */
  94                180,/*    121.8cm ~       130.5cm */
  95                150,/*    130.5cm ~       139.2cm */
  96                150,/*    139.2cm ~       147.9cm */
  97                150,/*    147.9cm ~       156.6cm */
  98                120,/*    156.6cm ~       165.3cm */
  99                120,/*    165.3cm ~       174.0cm */
 100          };
 101          
 102          const BYTE  TableHeight[] =
 103          {
 104                70, /*    0cm     ~       8.7cm   */
 105                70, /*    8.7cm   ~       17.4cm  */
 106                70, /*    17.4cm  ~       26.1cm  */
 107                70, /*    26.1cm  ~       34.8cm  */
 108                36, /*    34.8cm  ~       43.5cm  */
C51 COMPILER V9.60.0.0   DETECTOBJ                                                         08/08/2020 16:35:49 PAGE 3   

 109                34, /*    43.5cm  ~       52.2cm  */
 110                32, /*    52.2cm  ~       60.9cm  */
 111                28, /*    60.9cm  ~       69.6cm  */
 112                24, /*    69.6cm  ~       78.3cm  */
 113                20, /*    78.3cm  ~       87.0cm  */
 114                20, /*    87.0cm  ~       95.7cm  */
 115                20, /*    95.7cm  ~       104.4cm */
 116                16, /*    104.4cm ~       113.1cm */
 117                16, /*    113.1cm ~       121.8cm */
 118                14, /*    121.8cm ~       130.5cm */
 119                    14, /*        130.5cm ~       139.2cm */
 120                    14, /*        139.2cm ~       147.9cm */
 121                    14, /*        147.9cm ~       156.6cm */
 122                    10, /*        156.6cm ~       165.3cm */
 123                10, /*    165.3cm ~       174.0cm */
 124          };
 125          
 126          
 127          void Null (void)
 128          {
 129   1      
 130   1      }
 131          void DetObj_InitSelfCheckVar(void)
 132          {
 133   1          BYTE i;
 134   1          bSensorCheckFlag = TRUE;
 135   1          DetInfo.bDetTimes = 2;
 136   1          wSensorCheckTime = 300;
 137   1          CmpData.bFirstDataFlag = TRUE;
 138   1          NearestData.bRingTimeFlag = 0x0F;           //
 139   1          for(i=0;i<SN_NUM;i++)
 140   1          {
 141   2               Cmd.bSensorRun[i] = TRUE;
 142   2               NearestData.bEachNearestDistance[i] = 0xFF;;
 143   2          }
 144   1          NearestData.bNearestDistance = 0xFF;
 145   1          DetInfo.bDetState = DET_OBJ_DETECT_INIT;
 146   1          DetObj_Stop();
 147   1      }
 148          
 149          void DetObj_InitVariable(void)
 150          {
 151   1              WORD i,j;
 152   1              DetInfo.bDetState = 0;
 153   1              DetInfo.bID = 0;
 154   1              DetInfo.bDetTriggerFlag = 0;
 155   1              //DetInfo.bDetSnNum = 0;
 156   1              DetInfo.bDetTimes = 0;
 157   1              DetInfo.bDetWaitTime = 0;
 158   1              DetInfo.bDetNoiseDelayTime = 0;
 159   1              //DetInfo.wDetRealTime = 0;
 160   1      
 161   1              //DiagInfo.bErrSnNum = 0;
 162   1              //DiagInfo.wPowerUpChimeTime = 0;
 163   1              DiagInfo.bErrCounter = 0;
 164   1              DiagInfo.bKeepFlag = 0;
 165   1              for(i=0;i<SN_NUM;i++)
 166   1              {
 167   2                      DiagInfo.bSelfCheckResult[i] = 0;
 168   2              }
 169   1      
 170   1              RawData.wStartTime = 0;
 171   1              RawData.bAdcBfIndex = 0;
C51 COMPILER V9.60.0.0   DETECTOBJ                                                         08/08/2020 16:35:49 PAGE 4   

 172   1              for(i=0;i<10;i++)
 173   1              {
 174   2                      RawData.bAdcBuffer[i] = 0;
 175   2              }
 176   1              RawData.wRawDataIndex = 0;
 177   1              for(i=0;i<DETECT_BUFFER_LENGTH;i++)
 178   1              {
 179   2                      RawData.bRawDataBuffer[i] = 0;
 180   2              }
 181   1      
 182   1              AnsData.bDetSampThre = 0;
 183   1              AnsData.bObsSigStartFlag = 0;
 184   1          //AnsData.wObsSigStartCnt = 0;
 185   1          //AnsData.wObsSigOverCnt = 0;
 186   1              AnsData.wObsSigExitCnt = 0;
 187   1              AnsData.bObsSigVolInto = 0;
 188   1              AnsData.bObsSigVolExit = 0;
 189   1              AnsData.wObsSigTimeInto = 0;
 190   1              AnsData.wObsSigTimeWidth = 0;
 191   1              AnsData.bObsSigVolHeight = 0;
 192   1      #ifdef  EEPROM
                      AnsData.bSampSN = 0;
              #endif
 195   1      
 196   1              CmpData.bFirstDataFlag = 0;
 197   1          CmpData.bCurBfNumber = 0;
 198   1              CmpData.CCD.bDataValid = 0;
 199   1              CmpData.CCD.wDetTime = 0;
 200   1              CmpData.CCD.wRingTime = 0;
 201   1              CmpData.CCD.bDataNum = 0;
 202   1              CmpData.CCD.bSampThre = 0;
 203   1              for(i=0;i<OBJ_NUM;i++)
 204   1              {
 205   2                      CmpData.CCD.bObsDistance[i] = 0;
 206   2              }
 207   1              for(i=0;i<DETECT_CMP_BUFFER_LENGTH;i++)
 208   1              {
 209   2                      CmpData.EPD[i].bDataValid = 0;
 210   2                      CmpData.EPD[i].wDetTime = 0;
 211   2                      CmpData.EPD[i].wRingTime = 0;
 212   2                      CmpData.EPD[i].bDataNum = 0;
 213   2                      CmpData.EPD[i].bSampThre = 0;
 214   2                      for(j=0;j<OBJ_NUM;j++)
 215   2                      {
 216   3                              CmpData.EPD[i].bObsDistance[j] = 0;
 217   3                      }
 218   2                      CmpData.Ns[i].bEchoRaisedTimes = 0;
 219   2                      CmpData.Ns[i].bNoiseRaisedTimes = 0;
 220   2                      CmpData.Ns[i].dObsIntegralArea = 0;
 221   2                      CmpData.Ns[i].dNseIntegralArea = 0;
 222   2                      CmpData.Ns[i].bNoiseMuchFlag = 0;
 223   2                      CmpData.Ns[i].eObsNsType = OBS_BLUE;
 224   2              }
 225   1      
 226   1              NearestData.bRingTimeFlag = 0;
 227   1              NearestData.wUpdataDelay = 0;
 228   1              NearestData.bNearestDistance = 0;
 229   1              for(i=0;i<OBJ_NUM;i++)
 230   1              {
 231   2                      NearestData.bEachNearestDistance[i] = 0;
 232   2              }
 233   1              NearestData.wRingTime = 0;
 234   1              NearestData.bRingTimeBounceFlag = 0;
C51 COMPILER V9.60.0.0   DETECTOBJ                                                         08/08/2020 16:35:49 PAGE 5   

 235   1      
 236   1              ClrtData.wRingTime = 0;
 237   1              ClrtData.wTimeWidth = 0;
 238   1              ClrtData.bVolHeight = 0;
 239   1              ClrtData.bDistance = 0;
 240   1      
 241   1      }
 242          
 243          void DetObj_InitAllChannelDistance(void)
 244          {
 245   1          BYTE xdata i;
 246   1          DetInfo.bDetTimes = 2;
 247   1          CmpData.bFirstDataFlag = TRUE;
 248   1          NearestData.bRingTimeFlag = 0x0F;
 249   1          for(i=0;i<SN_NUM;i++)
 250   1          {
 251   2               NearestData.bEachNearestDistance[i] = 0xFF;
 252   2               Cmd.bDistance[i] = 0xFF;
 253   2               Cmd.bObsorient[i] = 0x00;
 254   2                       Cmd.bBuzzerInfo = 0x03;
 255   2          }
 256   1          NearestData.bNearestDistance = 0xFF;
 257   1          DetInfo.bDetState = WAIT_DET_CMD;
 258   1          DetObj_Stop();
 259   1      }
 260          
 261          void DetObj_RealTimeClock(void)
 262          {
 263   1          DetInfo.wDetRealTime++;
 264   1          if(NearestData.wUpdataDelay > 0)
 265   1          {
 266   2              NearestData.wUpdataDelay--;
 267   2          }
 268   1      }
 269          //
 270          //void DetObj_SelfCheck(void)
 271          //{
 272          //    switch(DetInfo.bDetState)
 273          //    {
 274          //        case DET_OBJ_DETECT_INIT:
 275          //            if(DetInfo.bDetWaitTime > 0 )
 276          //            {
 277          //                DetInfo.bDetWaitTime--;
 278          //            }
 279          //            else
 280          //            {
 281          //                if(DetInfo.bDetTimes > 0)
 282          //                {
 283          //                    DetInfo.bDetTimes --;
 284          //                }
 285          //                else
 286          //                {
 287          //                    DetObj_DiagnosticTheSensor();
 288          //                    DetObj_InitTheEPD();
 289          //                    DetObj_InitTheCCD();
 290          //                }
 291          //                DetObj_ClearTheRawDataBuff();
 292          //                /* Change the detect state. */
 293          //                DetInfo.bDetState = DET_OBJ_NOISE_SAMPLING;
 294          //            }
 295          //            break;
 296          //        case DET_OBJ_NOISE_SAMPLING:
 297          //            DetInfo.bDetWaitTime = DETECT_MAX_SAMPLING;
C51 COMPILER V9.60.0.0   DETECTOBJ                                                         08/08/2020 16:35:49 PAGE 6   

 298          //            DetObj_ClearTheRawDataBuff();
 299          //            ADC_InitDetect();
 300          //            DetObj_Start();
 301          //            DetInfo.bDetState = DET_OBJ_WAIT_SAMPLING;
 302          //            break;
 303          //        case DET_OBJ_WAIT_SAMPLING:
 304          //            if(DetInfo.bDetWaitTime > 0)DetInfo.bDetWaitTime--;
 305          //            else
 306          //            {
 307          //                DetObj_Stop();
 308          //                DetObj_CalSampNoise();
 309          //                DetInfo.bDetState = DET_OBJ_START_DETECT_OBSTACLE;
 310          //            }
 311          //            break;
 312          //      case DET_OBJ_START_DETECT_OBSTACLE:
 313          //            DetObj_ClearTheRawDataBuff();
 314          //            DetObj_ClearTheNoiseBuff();
 315          //            DetObj_InitTheEPD();
 316          //            DetObj_SendThe58KhzUltraSonic();/* Need polishing send ultrasonic wave used time*/
 317          //            ADC_InitDetect();
 318          //            DetObj_Start();
 319          //            DetInfo.bDetWaitTime = DETECT_MAX_DISTANCE_150CM;
 320          //            CmpData.EPD[CmpData.bCurBfNumber].wDetTime = DetInfo.wDetRealTime;
 321          //            DetInfo.bDetState = DET_OBJ_WAIT_ECHO;
 322          //            break;
 323          //        case DET_OBJ_WAIT_ECHO:
 324          //        {
 325          //            if(DetInfo.bDetWaitTime > 0)DetInfo.bDetWaitTime--;
 326          //            else
 327          //            {
 328          //                DetObj_Stop();
 329          //                DetObj_RawEchoDataAns();
 330          //                DetObj_DiagnosticTheRingTime();
 331          //                DetInfo.bDetNoiseDelayTime = 5;
 332          //                DetInfo.bDetState = DET_OBJ_DETECT_INIT;     /* Change the detect state. */
 333          //            }
 334          //            break;
 335          //        }
 336          //        default:
 337          //        {
 338          //            Cpu_InitHardwarePort();    /* Initial the hardware config for echo detecting block. */
 339          //            DetInfo.bDetState = DET_OBJ_DETECT_INIT;
 340          //            break;
 341          //        }
 342          //    }
 343          //}
 344          
 345          //#pragma optimize = none
 346          void DetObj_SendThe58KhzUltraSonic(void)
 347          {
 348   1          volatile BYTE i;
 349   1      
 350   1          Cpu_DisableInterrupt();
 351   1          for(i=PULE_NUM;i>0;i--)             /* Send the 58KHz ultrasonic. */
 352   1          {
 353   2              DRIVE_PORT_1 = 0;
 354   2              DRIVE_PORT_2 = 1;
 355   2              Delay1us(6);
 356   2              NOP();NOP();NOP();NOP();NOP();NOP();NOP();NOP();NOP();NOP();NOP();NOP();NOP();NOP();NOP();NOP();
 357   2              NOP();NOP();NOP();NOP();NOP();NOP();NOP();NOP();NOP();NOP();NOP();NOP();NOP();NOP();NOP();NOP();
 358   2              NOP();NOP();NOP();NOP();NOP();NOP();NOP();NOP();NOP();NOP();NOP();NOP();
 359   2              DRIVE_PORT_1 = 1;
 360   2              DRIVE_PORT_2 = 0;
C51 COMPILER V9.60.0.0   DETECTOBJ                                                         08/08/2020 16:35:49 PAGE 7   

 361   2              Delay1us(6);
 362   2              NOP();NOP();NOP();NOP();NOP();NOP();NOP();NOP();NOP();NOP();NOP();NOP();NOP();NOP();NOP();NOP();
 363   2              NOP();NOP();NOP();NOP();NOP();NOP();NOP();NOP();NOP();NOP();NOP();NOP();NOP();NOP();NOP();NOP();
 364   2              NOP();NOP();NOP();NOP();NOP();NOP();
 365   2          }
 366   1          DRIVE_PORT_1 = 0;
 367   1          DRIVE_PORT_2 = 0;
 368   1          RawData.wStartTime = PULE_NUM*17;
 369   1          Cpu_EnableInterrupt();
 370   1      }
 371          
 372          
 373          /*********************************************************************************************************
             -************
 374          ** Diagnostic.
 375          **********************************************************************************************************
             -***********/
 376          void DetObj_DiagnosticTheSensor(void)
 377          {
 378   1          if(DiagInfo.bErrCounter >  SN_ERR_THRESHOLD)
 379   1          {
 380   2              DiagInfo.bSelfCheckResult[DetInfo.bID] = 1;
 381   2          }
 382   1          else
 383   1          {
 384   2              DiagInfo.bSelfCheckResult[DetInfo.bID] = 0;
 385   2          }
 386   1      }
 387          
 388          /*********************************************************************************************************
             -************
 389          ** Process the echo.
 390          **********************************************************************************************************
             -***********/
 391          void DetObj_PreEchoProcess(void)
 392          {
 393   1      }
 394          
 395          /*********************************************************************************************************
             -************
 396          ** Diagnostic the ring time.
 397          **********************************************************************************************************
             -***********/
 398          void DetObj_DiagnosticTheRingTime(void)
 399          {
 400   1          if(NearestData.bRingTimeFlag > 0)
 401   1          {
 402   2              if((CmpData.EPD[CmpData.bCurBfNumber].wRingTime > RING_TIME_MIN_VALUE) &&
 403   2                 (CmpData.EPD[CmpData.bCurBfNumber].wRingTime < RING_TIME_MID_VALUE))
 404   2              {
 405   3                  NearestData.bRingTimeFlag >>= 1;
 406   3                  NearestData.wRingTime = CmpData.EPD[CmpData.bCurBfNumber].wRingTime;
 407   3                  if(DiagInfo.bErrCounter > 0)
 408   3                  {
 409   4                      DiagInfo.bErrCounter--;
 410   4                  }
 411   3              }
 412   2              else if((CmpData.EPD[CmpData.bCurBfNumber].wRingTime >= RING_TIME_MID_VALUE) &&
 413   2                      (CmpData.EPD[CmpData.bCurBfNumber].wRingTime < RING_TIME_MAX_VALUE_WITH_OBSTACLE))
 414   2              {
 415   3                  NearestData.bRingTimeFlag >>= 1;
 416   3                  NearestData.wRingTime = RING_TIME_MID_VALUE;
 417   3              }
C51 COMPILER V9.60.0.0   DETECTOBJ                                                         08/08/2020 16:35:49 PAGE 8   

 418   2              else
 419   2              {
 420   3                  if(DiagInfo.bErrCounter < 8)
 421   3                  {
 422   4                      DiagInfo.bErrCounter++;
 423   4                  }
 424   3              }
 425   2                      if(NearestData.wRingTime < RING_TIME_RECOVER_VALUE)
 426   2                      {
 427   3                              NearestData.wRingTime = RING_TIME_MID_VALUE;
 428   3                      }
 429   2          }
 430   1          else
 431   1          {
 432   2              /* Diagnostic the sensor. */
 433   2              if((CmpData.EPD[CmpData.bCurBfNumber].wRingTime > RING_TIME_MAX_VALUE_WITH_OBSTACLE) ||
 434   2                 (CmpData.EPD[CmpData.bCurBfNumber].wRingTime < RING_TIME_MIN_VALUE))
 435   2              {
 436   3                  if(DiagInfo.bErrCounter < 8)
 437   3                  {
 438   4                      DiagInfo.bErrCounter++;
 439   4                  }
 440   3              }
 441   2              else
 442   2              {
 443   3                  /* If the ring time is valid. Renew it, or abandon it. */
 444   3                  if(DiagInfo.bErrCounter > 0)
 445   3                  {
 446   4                      DiagInfo.bErrCounter--;
 447   4                  }
 448   3              }
 449   2          }
 450   1          DetObj_DiagnosticTheSensor();
 451   1      }
 452          
 453          ///*******************************************************************************************************
             -**************
 454          //** Save interrupt data into buff.
 455          //********************************************************************************************************
             -*************/
 456          
 457          void DetObj_Start(void)
 458          {
 459   1          Time_InitAdcTriggerTimer();
 460   1          Time_StartAdcTrigger();
 461   1          ADC_Start();
 462   1      }
 463          
 464          void DetObj_Stop(void)
 465          {
 466   1          Time_StopAdcTrigger();
 467   1          ADC_Stop();
 468   1      }
 469          
 470          void DetObj_InitTheAnalysisData(void)
 471          {
 472   1          AnsData.bObsSigStartFlag = FALSE;
 473   1      }
 474          
 475          /*********************************************************************************************************
             -************
 476          ** Initial the current buff.
 477          **********************************************************************************************************
C51 COMPILER V9.60.0.0   DETECTOBJ                                                         08/08/2020 16:35:49 PAGE 9   

             -***********/
 478          void DetObj_InitTheEPD(void)
 479          {
 480   1          BYTE i;
 481   1          CmpData.EPD[CmpData.bCurBfNumber].bDataValid = FALSE;
 482   1          CmpData.EPD[CmpData.bCurBfNumber].wDetTime = 0;
 483   1          CmpData.EPD[CmpData.bCurBfNumber].wRingTime = 0xFFFF;
 484   1          CmpData.EPD[CmpData.bCurBfNumber].bDataNum = 0;
 485   1      
 486   1          ClrtData.bDistance  = 0XFF;
 487   1          ClrtData.bVolHeight = 0;
 488   1          ClrtData.wTimeWidth = 0;
 489   1          ClrtData.wRingTime  = 0;
 490   1      
 491   1          for(i=0; i<OBJ_NUM; i++)
 492   1          {
 493   2              CmpData.EPD[CmpData.bCurBfNumber].bObsDistance[i] = NO_OBJ;
 494   2          }
 495   1      }
 496          
 497          /*********************************************************************************************************
             -************
 498          ** Initial the compare buff.
 499          **********************************************************************************************************
             -***********/
 500          void DetObj_InitTheCCD(void)
 501          {
 502   1          BYTE i;
 503   1          CmpData.CCD.bDataValid = FALSE;
 504   1          CmpData.CCD.wDetTime = 0;
 505   1          CmpData.CCD.wRingTime = 0xFFFF;
 506   1          CmpData.CCD.bDataNum = 0;
 507   1          DiagInfo.bKeepFlag = FALSE;
 508   1      
 509   1          CmpData.bCurBfNumber = 0;
 510   1          CmpData.bFirstDataFlag = TRUE;
 511   1          for(i=0; i<DETECT_CMP_BUFFER_LENGTH; i++)
 512   1          {
 513   2              CmpData.EPD[i].bDataValid = FALSE;
 514   2          }
 515   1          for(i=0; i<OBJ_NUM; i++)
 516   1          {
 517   2              CmpData.CCD.bObsDistance[i] = NO_OBJ;
 518   2          }
 519   1      }
 520          
 521          /*********************************************************************************************************
             -************
 522          ** Clear the raw data buff.
 523          **********************************************************************************************************
             -***********/
 524          void DetObj_ClearTheRawDataBuff(void)
 525          {
 526   1          WORD i;
 527   1          for(i=0; i<DETECT_BUFFER_LENGTH;i++)
 528   1          {
 529   2              RawData.bRawDataBuffer[i] = 0;
 530   2          }
 531   1          RawData.wRawDataIndex = 0;
 532   1          RawData.wStartTime = 0;
 533   1          DetObj_InitTheAnalysisData();
 534   1      }
 535          
C51 COMPILER V9.60.0.0   DETECTOBJ                                                         08/08/2020 16:35:49 PAGE 10  

 536          BYTE GetDistance(WORD ObsTime,WORD EchoWidth,BYTE VolHeight)
 537          {
 538   1          BYTE ret = NO_OBJ;
 539   1          BYTE Index;
 540   1      
 541   1          Index = ObsTime >> 9;
 542   1          if(EchoWidth >= TableWidth[Index] && VolHeight >= TableHeight[Index])
 543   1          {
 544   2              ObsTime >>= 7;
 545   2              ret = (ObsTime*557) >> 8;
 546   2          }
 547   1          return ret;
 548   1      }
 549          
 550          /*********************************************************************************************************
             -************
 551          ** Clear the noise buff.
 552          **********************************************************************************************************
             -***********/
 553          void DetObj_ClearTheNoiseBuff(void)
 554          {
 555   1          CmpData.Ns[CmpData.bCurBfNumber].eObsNsType= OBS_BLUE;
 556   1          CmpData.Ns[CmpData.bCurBfNumber].bEchoRaisedTimes = 0;
 557   1          CmpData.Ns[CmpData.bCurBfNumber].bNoiseRaisedTimes = 0;
 558   1          CmpData.Ns[CmpData.bCurBfNumber].dNseIntegralArea = 0;
 559   1          CmpData.Ns[CmpData.bCurBfNumber].dObsIntegralArea = 0;
 560   1          CmpData.Ns[CmpData.bCurBfNumber].bNoiseMuchFlag = FALSE;
 561   1      }
 562          
 563          void DetObj_CopySamplingBuffer(BYTE* SP, BYTE* EP, BYTE Len)
 564          {
 565   1          BYTE i;
 566   1          for(i=0; i<Len; i++)
 567   1          {
 568   2              *(EP+i) = *(SP+i);
 569   2          }
 570   1      }
 571          
 572          #define NULL_DATA_LEN    2
 573          void DetObj_CalSampNoise(void)
 574          {
 575   1          BYTE xdata i,j;
 576   1          BYTE xdata temp;
 577   1          BYTE xdata add;
 578   1          WORD xdata AdLow,AdMid,AdHigh;
 579   1      
 580   1          DetObj_CopySamplingBuffer(RawData.bRawDataBuffer,(&RawData.bRawDataBuffer[RawData.wRawDataIndex+1]),(4
             -8+NULL_DATA_LEN));
 581   1      
 582   1          add = RawData.wRawDataIndex + 1 + NULL_DATA_LEN;
 583   1      
 584   1          for(i=add; i<48+add; i++)
 585   1          {
 586   2              for(j=i; j<48+add; j++)
 587   2              {
 588   3                  if(RawData.bRawDataBuffer[i] > RawData.bRawDataBuffer[j])
 589   3                  {
 590   4                      temp = RawData.bRawDataBuffer[i];
 591   4                      RawData.bRawDataBuffer[i] = RawData.bRawDataBuffer[j];
 592   4                      RawData.bRawDataBuffer[j] = temp;
 593   4                  }
 594   3              }
 595   2          }
C51 COMPILER V9.60.0.0   DETECTOBJ                                                         08/08/2020 16:35:49 PAGE 11  

 596   1          AdLow = 0;
 597   1          AdMid = 0;
 598   1          AdHigh = 0;
 599   1          for(i=add; i<16+add;i++)
 600   1          {
 601   2              AdLow  += RawData.bRawDataBuffer[i];
 602   2              AdMid  += RawData.bRawDataBuffer[i+16];
 603   2              AdHigh += RawData.bRawDataBuffer[i+32];
 604   2          }
 605   1          AdLow >>= 4;
 606   1          AdMid >>= 4;
 607   1          AdHigh>>= 4;
 608   1      
 609   1          AnsData.bDetSampThre = AdMid + ((AdHigh-AdMid)>>2);
 610   1      
 611   1          if(AnsData.bDetSampThre > DETECT_NOISE_BASE_VOL)
 612   1          {
 613   2              temp = AnsData.bDetSampThre - DETECT_NOISE_BASE_VOL;
 614   2                      temp = temp>>2;
 615   2                      AnsData.bDetSampThre += (temp*temp); //scaled-up
 616   2          }
 617   1      
 618   1      #ifdef EEPROM
                  AnsData.bDetSampThre += AnsData.bSampSN;
              #endif
 621   1      
 622   1          if(AnsData.bDetSampThre > DETECT_NOISE_MAX_VOL)
 623   1          {
 624   2              AnsData.bDetSampThre = DETECT_NOISE_MAX_VOL;
 625   2              CmpData.Ns[CmpData.bCurBfNumber].eObsNsType = OBS_RED;
 626   2          }
 627   1          else if(AnsData.bDetSampThre > DETECT_NOISE_MID_VOL)
 628   1          {
 629   2              CmpData.Ns[CmpData.bCurBfNumber].eObsNsType = OBS_YELLOW;
 630   2          }
 631   1          else
 632   1          {
 633   2              CmpData.Ns[CmpData.bCurBfNumber].eObsNsType = OBS_BLUE;
 634   2          }
 635   1          CmpData.EPD[CmpData.bCurBfNumber].bSampThre = AnsData.bDetSampThre;
 636   1      
 637   1          DetObj_RawNoiseDataAns();
 638   1      
 639   1      }
 640          
 641          
 642          void DetObj_RawFilter(void)
 643          {
 644   1          WORD xdata i = 0;
 645   1          WORD xdata j = 0;
 646   1          WORD xdata k = 0;
 647   1          BYTE xdata Temp = 0;
 648   1      
 649   1      #ifdef   START_VALUE_POLISHING
 650   1          for(i=0;i<RawData.wRawDataIndex;i++)
 651   1          {
 652   2              if(RawData.bRawDataBuffer[i] != 0)
 653   2              {
 654   3                  Temp = RawData.bRawDataBuffer[i];
 655   3                  j = i;
 656   3                  if(j > START_VALUE_POLISHING_LEN)
 657   3                  {
 658   4                      DiagInfo.bErrCounter++;
C51 COMPILER V9.60.0.0   DETECTOBJ                                                         08/08/2020 16:35:49 PAGE 12  

 659   4                  }
 660   3                  break;
 661   3              }
 662   2          }
 663   1          for(i=0; i<j; i++)
 664   1          {
 665   2              RawData.bRawDataBuffer[i] = Temp;
 666   2          }
 667   1      #endif
 668   1      
 669   1      #ifdef   SINGLE_POINT_JUMP_ZERO_FILTER
 670   1          for(i=1; i<(RawData.wRawDataIndex-1);i++)
 671   1          {
 672   2              if(RawData.bRawDataBuffer[i] == 0)
 673   2              {
 674   3                  /*if(RawData.bRawDataBuffer[i-1] > (AnsData.bDetSampThre<<1) &&
 675   3                     RawData.bRawDataBuffer[i+1] > (AnsData.bDetSampThre<<1)   )*/
 676   3                  {
 677   4                      RawData.bRawDataBuffer[i] = RawData.bRawDataBuffer[i-1];
 678   4                  }
 679   3              }
 680   2          }
 681   1      #endif
 682   1      
 683   1      #ifdef    PEAK_DISTURB_FILTER
 684   1          for(i=5; i<(RawData.wRawDataIndex-2);i++)
 685   1          {
 686   2              if(RawData.bRawDataBuffer[i+1] > RawData.bRawDataBuffer[i]+PEAK_DISTURB_FILTER_HIGH &&
 687   2                 RawData.bRawDataBuffer[i+2] > RawData.bRawDataBuffer[i]+PEAK_DISTURB_FILTER_HIGH+(PEAK_DISTURB_
             -FILTER_HIGH>>1))
 688   2              {
 689   3                  for(j=i+1; j<(i+(PEAK_DISTURB_FILTER_WIDTH/COUNT_TIME_UNIT));j++)
 690   3                  {
 691   4                      if(RawData.bRawDataBuffer[j] < RawData.bRawDataBuffer[i]+(PEAK_DISTURB_FILTER_HIGH>>2))
 692   4                      {
 693   5                          CmpData.Ns[CmpData.bCurBfNumber].bEchoRaisedTimes++;
 694   5                          for(k=i; k<j;k++)
 695   5                          {
 696   6                              RawData.bRawDataBuffer[k] = RawData.bRawDataBuffer[i-1];
 697   6                          }
 698   5                          break;
 699   5                      }
 700   4                  }
 701   3              }
 702   2          }
 703   1      #endif
 704   1      }
 705          
 706          void DetObj_RawEchoDataAns(void)
 707          {
 708   1          WORD xdata i;
 709   1          BYTE xdata Distc;
 710   1          WORD xdata EchoWidth;
 711   1      
 712   1          WORD xdata ObsStartThre;
 713   1          WORD xdata ObsExitThreFixed;
 714   1      
 715   1      
 716   1          ObsStartThre = CmpData.EPD[CmpData.bCurBfNumber].bSampThre + OBSTACLE_START_VOL;
 717   1          /* subtractive sampling noise */
 718   1          ObsExitThreFixed = CmpData.EPD[CmpData.bCurBfNumber].bSampThre -
 719   1                            (CmpData.EPD[CmpData.bCurBfNumber].bSampThre >> OBSTACLE_EXIT_VOL_SHIFT);
 720   1      
C51 COMPILER V9.60.0.0   DETECTOBJ                                                         08/08/2020 16:35:49 PAGE 13  

 721   1          DetObj_RawFilter();
 722   1      
 723   1          RawData.bRawDataBuffer[RawData.wRawDataIndex-1] = 0; /* the farthest distance exit flag */
 724   1      
 725   1          /* Analyze detect data */
 726   1          for(i=0; i<RawData.wRawDataIndex;i++)
 727   1          {
 728   2              CmpData.Ns[CmpData.bCurBfNumber].dObsIntegralArea += RawData.bRawDataBuffer[i];
 729   2              if(RawData.bRawDataBuffer[i] > ObsStartThre)
 730   2              {
 731   3                  if(AnsData.bObsSigStartFlag == FALSE)
 732   3                  {
 733   4                      //AnsData.wObsSigOverCnt = 0;
 734   4                      //if(++AnsData.wObsSigStartCnt > 0)
 735   4                      {
 736   5                          AnsData.bObsSigStartFlag = TRUE;
 737   5                          AnsData.bObsSigVolInto = RawData.bRawDataBuffer[i];
 738   5                          AnsData.wObsSigTimeInto = RawData.wStartTime + i*COUNT_TIME_UNIT;
 739   5                          AnsData.wObsSigTimeWidth = 0;
 740   5                          AnsData.bObsSigVolHeight = 0;
 741   5                          AnsData.wObsSigExitCnt = 0;
 742   5                      }
 743   4                  }
 744   3              }
 745   2              /* this possible rewrite packaging a function , differentiate the different of noise*/
 746   2              if(RawData.bRawDataBuffer[i] < (ObsExitThreFixed+(AnsData.bObsSigVolHeight>>OBSTACLE_EXIT_VOL_SHIF
             -T)))
 747   2              {
 748   3                  if(AnsData.bObsSigStartFlag == TRUE)
 749   3                  {
 750   4                      //AnsData.wObsSigStartCnt = 0;
 751   4                      //if(++AnsData.wObsSigOverCnt > 0)
 752   4                      {
 753   5                          AnsData.bObsSigStartFlag = FALSE;
 754   5                          if(AnsData.bObsSigVolHeight > (DETECT_NOISE_BASE_VOL<<1)
 755   5                          && AnsData.wObsSigTimeWidth > DETECT_NOISE_WIDTH )
 756   5                          {
 757   6                              CmpData.Ns[CmpData.bCurBfNumber].bEchoRaisedTimes++;
 758   6                          }
 759   5                          AnsData.bObsSigVolExit = RawData.bRawDataBuffer[i];
 760   5                          /* generate obstacle distance */
 761   5                          if(CmpData.EPD[CmpData.bCurBfNumber].bDataNum == 0)
 762   5                          {
 763   6                              CmpData.EPD[CmpData.bCurBfNumber].wRingTime = RawData.wStartTime + AnsData.wObsSig
             -TimeWidth + ((AnsData.bObsSigVolExit)<<0);
 764   6                              ClrtData.wRingTime = CmpData.EPD[CmpData.bCurBfNumber].wRingTime;
 765   6                              CmpData.EPD[CmpData.bCurBfNumber].bDataNum++;
 766   6                              continue;
 767   6                          }
 768   5      
 769   5      #ifdef  OBS_ECHO_WIDTH_COMPEN
 770   5                          EchoWidth = AnsData.wObsSigTimeWidth + ((AnsData.bObsSigVolInto + AnsData.bObsSigVolEx
             -it) << 0); // y = x;
 771   5      #else
                                  EchoWidth = AnsData.wObsSigTimeWidth;
              #endif
 774   5                          if(CmpData.EPD[CmpData.bCurBfNumber].bDataNum < OBJ_NUM)
 775   5                          {
 776   6                              Distc = GetDistance(AnsData.wObsSigTimeInto,EchoWidth,AnsData.bObsSigVolHeight);
 777   6                              if(Distc != NO_OBJ)
 778   6                              {
 779   7                                  CmpData.EPD[CmpData.bCurBfNumber].bObsDistance[CmpData.EPD[CmpData.bCurBfNumbe
             -r].bDataNum] = Distc;
C51 COMPILER V9.60.0.0   DETECTOBJ                                                         08/08/2020 16:35:49 PAGE 14  

 780   7                                  if(CmpData.EPD[CmpData.bCurBfNumber].bDataNum == 1)
 781   7                                  {
 782   8                                      ClrtData.wTimeWidth = EchoWidth;
 783   8                                      ClrtData.bVolHeight = AnsData.bObsSigVolHeight;
 784   8                                     // ClrtData.bDistance = NearestData.bEachNearestDistance[DetInfo.bID];
 785   8                                  }
 786   7                                  CmpData.EPD[CmpData.bCurBfNumber].bDataNum++;
 787   7                              }
 788   6                          }
 789   5                      }
 790   4                  }
 791   3              }
 792   2      
 793   2              if(AnsData.bObsSigStartFlag == TRUE)
 794   2              {
 795   3                  AnsData.wObsSigTimeWidth += COUNT_TIME_UNIT;
 796   3                  if(AnsData.bObsSigVolHeight < RawData.bRawDataBuffer[i])
 797   3                  {
 798   4                      AnsData.bObsSigVolHeight = RawData.bRawDataBuffer[i];
 799   4                  }
 800   3                  /*voltage signel height donot increase to time，exit check; use to sampling voltage is relativ
             -ely low*/
 801   3                  if(AnsData.bObsSigVolHeight < (ObsStartThre <<1) &&
 802   3                     AnsData.wObsSigTimeWidth < ((WORD)COUNT_TIME_UNIT<<3)) /* sampling of 8 time */
 803   3                  {
 804   4                      if(++AnsData.wObsSigExitCnt >= 4)
 805   4                      {
 806   5                          AnsData.bObsSigStartFlag = FALSE;
 807   5                      }
 808   4                  }
 809   3              }
 810   2          }
 811   1      
 812   1          CmpData.EPD[CmpData.bCurBfNumber].bDataValid = TRUE;
 813   1      
 814   1      }
 815          
 816          void DetObj_RawNoiseDataAns(void)
 817          {
 818   1          WORD xdata i = 0;
 819   1      
 820   1          RawData.bRawDataBuffer[RawData.wRawDataIndex-1] = 0; /* the farthest distance exit flag */
 821   1      
 822   1          /* Analyze noise data */
 823   1          for(i=0; i<RawData.wRawDataIndex;i++)
 824   1          {
 825   2              CmpData.Ns[CmpData.bCurBfNumber].dNseIntegralArea += RawData.bRawDataBuffer[i];
 826   2              if(RawData.bRawDataBuffer[i] > AnsData.bDetSampThre+OBSTACLE_START_VOL)
 827   2              {
 828   3                  if(AnsData.bObsSigStartFlag == FALSE)
 829   3                  {
 830   4                      //AnsData.wObsSigOverCnt = 0;
 831   4                      //if(++AnsData.wObsSigStartCnt > 1)
 832   4                      {
 833   5                          AnsData.bObsSigStartFlag = TRUE;
 834   5                          AnsData.bObsSigVolHeight = 0;
 835   5                          AnsData.wObsSigTimeWidth = 0;
 836   5                      }
 837   4                  }
 838   3              }
 839   2              else if(RawData.bRawDataBuffer[i] < (AnsData.bObsSigVolHeight>>OBSTACLE_EXIT_VOL_SHIFT))
 840   2              {
 841   3                  if(AnsData.bObsSigStartFlag == TRUE)
C51 COMPILER V9.60.0.0   DETECTOBJ                                                         08/08/2020 16:35:49 PAGE 15  

 842   3                  {
 843   4                      //AnsData.wObsSigStartCnt = 0;
 844   4                      //if(++AnsData.wObsSigOverCnt > 0)
 845   4                      {
 846   5                          AnsData.bObsSigStartFlag = FALSE;
 847   5                          if(AnsData.bObsSigVolHeight > (DETECT_NOISE_BASE_VOL<<1)
 848   5                          && AnsData.wObsSigTimeWidth > DETECT_NOISE_WIDTH )
 849   5                          {
 850   6                              CmpData.Ns[CmpData.bCurBfNumber].bNoiseRaisedTimes++;
 851   6                          }
 852   5                      }
 853   4                  }
 854   3              }
 855   2      
 856   2              if(AnsData.bObsSigStartFlag == TRUE)
 857   2              {
 858   3                  AnsData.wObsSigTimeWidth += COUNT_TIME_UNIT;
 859   3                  if(AnsData.bObsSigVolHeight < RawData.bRawDataBuffer[i])
 860   3                  {
 861   4                      AnsData.bObsSigVolHeight = RawData.bRawDataBuffer[i];
 862   4                  }
 863   3              }
 864   2          }
 865   1      }
 866          
 867          /*********************************************************************************************************
             -************
 868          ** Detect the obstacle.
 869          **********************************************************************************************************
             -***********/
 870          void DetObj_DetTheObj(void)
 871          {
 872   1          switch(DetInfo.bDetState)
 873   1          {
 874   2            case WAIT_DET_CMD:
 875   2                  /* add your code to here */
 876   2                      Cmd_Process();
 877   2                  //DetInfo.bDetTriggerFlag = TRUE;
 878   2                  if(DetInfo.bDetTriggerFlag == TRUE)//Detect cmd is true
 879   2                  {
 880   3                      DetInfo.bDetTriggerFlag = FALSE;
 881   3                      DetObj_InitTheCCD();
 882   3                      DetInfo.bDetNoiseDelayTime = 0;//Wait data send
 883   3                      DetInfo.bDetTimes = DET_CMP_TIMES;
 884   3                      DetInfo.bDetState = DET_OBJ_DETECT_INIT;
 885   3                  }
 886   2      
 887   2                  break;
 888   2            case DET_OBJ_DETECT_INIT:
 889   2                  if(DetInfo.bDetNoiseDelayTime > 0)DetInfo.bDetNoiseDelayTime--;
 890   2                  else
 891   2                  {
 892   3                      DetInfo.bDetState = DET_OBJ_NOISE_SAMPLING;
 893   3                  }
 894   2                  break;
 895   2            case DET_OBJ_NOISE_SAMPLING:
 896   2                  DetInfo.bDetWaitTime = DETECT_MAX_SAMPLING;
 897   2                  DetObj_ClearTheRawDataBuff();
 898   2                  DetObj_ClearTheNoiseBuff();
 899   2                              ADC_InitDetect();
 900   2                              DetObj_Start();
 901   2                              DetInfo.bDetState = DET_OBJ_WAIT_SAMPLING;
 902   2                  break;
C51 COMPILER V9.60.0.0   DETECTOBJ                                                         08/08/2020 16:35:49 PAGE 16  

 903   2            case DET_OBJ_WAIT_SAMPLING:
 904   2                  if(DetInfo.bDetWaitTime > 0)DetInfo.bDetWaitTime--;
 905   2                  else
 906   2                  {
 907   3                      DetObj_Stop();
 908   3                      DetObj_CalSampNoise();
 909   3                      DetInfo.bDetState = DET_OBJ_START_DETECT_OBSTACLE;
 910   3                  }
 911   2                  break;
 912   2            case DET_OBJ_START_DETECT_OBSTACLE:
 913   2                  DetObj_ClearTheRawDataBuff();
 914   2                  DetObj_InitTheEPD();
 915   2                  DetObj_SendThe58KhzUltraSonic();/* Need polishing send ultrasonic wave used time*/
 916   2                  ADC_InitDetect();
 917   2                  DetObj_Start();
 918   2                  DetInfo.bDetWaitTime = DETECT_MAX_DISTANCE_150CM;
 919   2                  CmpData.EPD[CmpData.bCurBfNumber].wDetTime = DetInfo.wDetRealTime;
 920   2      
 921   2                  DetInfo.bDetState = DET_OBJ_WAIT_ECHO;
 922   2                  break;
 923   2            case DET_OBJ_WAIT_ECHO:
 924   2                  if(DetInfo.bDetWaitTime > 0)DetInfo.bDetWaitTime--;
 925   2                  else
 926   2                  {
 927   3                      DetObj_Stop();
 928   3                      DetObj_RawEchoDataAns();
 929   3                      DetInfo.bDetState = DET_OBJ_HANDLE_NOISE;
 930   3                  }
 931   2                  break;
 932   2            case DET_OBJ_HANDLE_NOISE:
 933   2                  DetObj_DiagnosticTheRingTime();
 934   2                  /*  Much disturb keep befor status arithmetic */
 935   2                  if(
 936   2                      CmpData.Ns[CmpData.bCurBfNumber].eObsNsType == OBS_RED ||
 937   2                        (
 938   2                        CmpData.Ns[CmpData.bCurBfNumber].bEchoRaisedTimes >= 22
 939   2                    ||  CmpData.Ns[CmpData.bCurBfNumber].bNoiseRaisedTimes>= 3
 940   2                    ||  CmpData.Ns[CmpData.bCurBfNumber].dObsIntegralArea >= ((DWORD)75*DETECT_MAX_DISTANCE_150C
             -M*1000/COUNT_TIME_UNIT)
 941   2                    ||  CmpData.Ns[CmpData.bCurBfNumber].dNseIntegralArea >= ((DWORD)20*DETECT_MAX_NOISE_TIME*10
             -00/COUNT_TIME_UNIT)
 942   2                        )
 943   2                     )
 944   2                  {
 945   3                      DetInfo.bDetTimes = 0;
 946   3                      DetObj_HoldTheObstaclestate();
 947   3                      CmpData.Ns[CmpData.bCurBfNumber].bNoiseMuchFlag = TRUE;
 948   3                  }
 949   2                  else
 950   2                  {
 951   3                      DetObj_CompareTheData();
 952   3                  }
 953   2                  DetInfo.bDetState = DET_OBJ_GENERATE_RETURN;
 954   2                  break;
 955   2            case DET_OBJ_GENERATE_RETURN:
 956   2                  DetObj_ProcessTheRingTime();
 957   2                  if(bSensorCheckFlag == TRUE)DetInfo.bDetTimes++;
 958   2                  if(DetInfo.bDetTimes > 0)
 959   2                  {
 960   3                      DetInfo.bDetTimes --;
 961   3                      DetInfo.bDetNoiseDelayTime = DetectInterval[DetInfo.wDetRealTime%INTERVAL_LEN];
 962   3                      CmpData.bCurBfNumber = (CmpData.bCurBfNumber+1)%DETECT_CMP_BUFFER_LENGTH;
 963   3                      DetInfo.bDetState = DET_OBJ_DETECT_INIT;
C51 COMPILER V9.60.0.0   DETECTOBJ                                                         08/08/2020 16:35:49 PAGE 17  

 964   3                  }
 965   2                  else
 966   2                  {
 967   3                      DetObj_GenerateTheNearestObstacle();
 968   3                      DetInfo.bDetState = WAIT_DET_CMD;
 969   3                      if(DetInfo.bID == ID_MASTER)
 970   3                      {
 971   4                              Cmd_NextSensorDet(FALSE);
 972   4                              Cmd.CmdStatus = MST_DRV_SENSOR;
 973   4                      }
 974   3                      else
 975   3                      {
 976   4                              if(Cmd.CmdStatus == SLV_CALIBRATION_BACK)  //workfrock command
 977   4                              {
 978   5                                      Cmd.CmdStatus = SLV_CALIBRATION_BACK;
 979   5                              }
 980   4                              else//detect
 981   4                              {
 982   5                                      Cmd.CmdStatus = SLV_DISTANCE_BACK;
 983   5                              }
 984   4      
 985   4                      }
 986   3                  }
 987   2                  break;
 988   2            default:
 989   2                  DetInfo.bDetState = DET_OBJ_DETECT_INIT;
 990   2                  break;
 991   2          }
 992   1      }
 993          
 994          void DetObj_HoldTheObstaclestate(void)
 995          {
 996   1          BYTE xdata i;
 997   1          CmpData.bFirstDataFlag = FALSE;
 998   1          NearestData.bRingTimeBounceFlag = FALSE;
 999   1          CmpData.EPD[CmpData.bCurBfNumber].bDataNum = 1;
1000   1          NearestData.wUpdataDelay = DETECT_DELAY_UPDATE_HIGH;
1001   1          CmpData.CCD.wRingTime = NearestData.wRingTime;
1002   1          DiagInfo.bKeepFlag = TRUE;
1003   1          CmpData.CCD.bObsDistance[0] = NearestData.bEachNearestDistance[DetInfo.bID];
1004   1          for(i=1; i<OBJ_NUM; i++)
1005   1          {
1006   2              CmpData.CCD.bObsDistance[i] = NO_OBJ;
1007   2          }
1008   1      }
1009          
1010          /*********************************************************************************************************
             -************
1011          ** Generate the nearest obstacle.
1012          **********************************************************************************************************
             -***********/
1013          void DetObj_GenerateTheNearestObstacle(void)
1014          {
1015   1          BYTE xdata i,bDis,bDiff;
1016   1          BYTE bFrockDis;
1017   1      
1018   1          /* Frock data */
1019   1          bFrockDis = 0xFF;
1020   1          for(i=0;i<CmpData.CCD.bDataNum;i++)
1021   1          {
1022   2              if(bFrockDis > CmpData.CCD.bObsDistance[i])
1023   2              {
1024   3                      bFrockDis= CmpData.CCD.bObsDistance[i];
C51 COMPILER V9.60.0.0   DETECTOBJ                                                         08/08/2020 16:35:49 PAGE 18  

1025   3              }
1026   2          }
1027   1          ClrtData.bDistance = bFrockDis;
1028   1      
1029   1      
1030   1          /* Get the nearest obstacle of this time detected. */
1031   1          bDis = NO_OBJ;
1032   1          for(i=0;i<CmpData.CCD.bDataNum;i++)
1033   1          {
1034   2              if(CmpData.CCD.bObsDistance[i] > EachSNMaxDistance[DetInfo.bID])
1035   2              {
1036   3                  CmpData.CCD.bObsDistance[i] = NO_OBJ;
1037   3              }
1038   2          }
1039   1      
1040   1          for(i=0;i<CmpData.CCD.bDataNum;i++)
1041   1          {
1042   2              if(bDis > CmpData.CCD.bObsDistance[i])
1043   2              {
1044   3                  bDis = CmpData.CCD.bObsDistance[i];
1045   3              }
1046   2          }
1047   1          /* use for Continue alarming to ring time is solder projection*/
1048   1          if(bDis < 25)
1049   1          {
1050   2              if(bDis > 20)
1051   2              {
1052   3                  bDis -= 3;
1053   3              }
1054   2              else /* ring time break */
1055   2              {
1056   3                  if(  (bDis != OBSTACLE_IN_RING_TIME_VALUE)
1057   3                     &&(bDis != OBSTACLE_IN_CONTINUOUS_DISTANCE_DELAY)
1058   3                     &&(bDis != OBSTACLE_IN_CONTINUOUS))
1059   3                  {
1060   4                      /* hold the state */
1061   4                      bDis = NearestData.bEachNearestDistance[DetInfo.bID];
1062   4                  }
1063   3              }
1064   2          }
1065   1      
1066   1          if(bDis > MAX_DETECT_DISTANCE)
1067   1          {
1068   2              /*if(
1069   2                 (NearestData.bEachNearestDistance[DetInfo.bID] <= CONTINUOUS_CHIME_DISTANCE)
1070   2               &&(NearestData.bEachNearestDistance[DetInfo.bID] != OBSTACLE_IN_CONTINUOUS_DISTANCE_DELAY)
1071   2                 )
1072   2              {
1073   2                  if(   CmpData.Ns[CmpData.bCurBfNumber].bEchoRaisedTimes > 8
1074   2                    ||  CmpData.Ns[CmpData.bCurBfNumber].dObsIntegralArea > ((DWORD)35*DETECT_MAX_DISTANCE_150CM
             -*1000/COUNT_TIME_UNIT)
1075   2                    )
1076   2                  {
1077   2                      NearestData.wUpdataDelay= DETECT_DELAY_UPDATE_MID;
1078   2                  }
1079   2                  else
1080   2                  {
1081   2                      NearestData.wUpdataDelay= DETECT_DELAY_UPDATE_LOW;
1082   2                  }
1083   2                  NearestData.bEachNearestDistance[DetInfo.bID] = OBSTACLE_IN_CONTINUOUS_DISTANCE_DELAY;
1084   2              }*/
1085   2      
1086   2              if(NearestData.wUpdataDelay == 0)
C51 COMPILER V9.60.0.0   DETECTOBJ                                                         08/08/2020 16:35:49 PAGE 19  

1087   2              {
1088   3                  NearestData.bEachNearestDistance[DetInfo.bID] = NO_OBJ;
1089   3              }
1090   2          }
1091   1          else
1092   1          {
1093   2              if(bDis < CONTINUOUS_CHIME_DISTANCE)
1094   2              {
1095   3                  if(bDis < 25)
1096   3                      NearestData.bEachNearestDistance[DetInfo.bID] = OBSTACLE_IN_CONTINUOUS;
1097   3                  else
1098   3                      NearestData.bEachNearestDistance[DetInfo.bID] = bDis;
1099   3                  NearestData.wUpdataDelay = DETECT_DELAY_UPDATE_HIGH;
1100   3              }
1101   2              else if(bDis < MID_DETECT_DISTANCE)
1102   2              {
1103   3                  NearestData.bEachNearestDistance[DetInfo.bID] = bDis;
1104   3                  NearestData.wUpdataDelay= DETECT_DELAY_UPDATE_LOW;
1105   3              }
1106   2              else
1107   2              {
1108   3                  NearestData.bEachNearestDistance[DetInfo.bID] = bDis;
1109   3                  NearestData.wUpdataDelay= DETECT_DELAY_UPDATE_LOW;
1110   3              }
1111   2          }
1112   1      
1113   1          /* Get the nearest obstacle of all the sensor detected. */
1114   1          bDis = NO_OBJ;
1115   1          for(i=0;i<SN_NUM;i++)
1116   1          {
1117   2              if(bDis > NearestData.bEachNearestDistance[i])
1118   2              {
1119   3                  bDis = NearestData.bEachNearestDistance[i];
1120   3              }
1121   2          }
1122   1          /* Compare the distance to judge if the obstacle has been moved. */
1123   1          if(bDis > NearestData.bNearestDistance)
1124   1          {
1125   2              /* The obstacle move far away from the vehicle. */
1126   2              /* Compute the difference. */
1127   2              bDiff = bDis - NearestData.bNearestDistance;
1128   2              if(bDiff > OBSTACLE_MOVE_FAR_AWAY)
1129   2              {
1130   3                  /* Need to change the distance display. */
1131   3                  NearestData.bNearestDistance = bDis;
1132   3              }
1133   2          }
1134   1          else
1135   1          {
1136   2              /* The obstacle move close to the vehicle. */
1137   2              bDiff = NearestData.bNearestDistance - bDis;
1138   2              if(bDiff > OBSTACLE_MOVE_CLOSE)
1139   2              {
1140   3                  /* Need to change the distance display. */
1141   3                  NearestData.bNearestDistance = bDis;
1142   3              }
1143   2          }
1144   1      
1145   1      
1146   1      }
1147          
1148          
1149          /*********************************************************************************************************
C51 COMPILER V9.60.0.0   DETECTOBJ                                                         08/08/2020 16:35:49 PAGE 20  

             -************
1150          ** Process the ring time.
1151          **********************************************************************************************************
             -***********/
1152          void DetObj_ProcessTheRingTime(void)
1153          {
1154   1           WORD xdata wRingTimeDiff;
1155   1      
1156   1          if(CmpData.Ns[CmpData.bCurBfNumber].bNoiseMuchFlag == TRUE)return;
1157   1          if(CmpData.CCD.wRingTime == 0xFFFF)return; /* Current sensor is failure */
1158   1      
1159   1          if(NearestData.bRingTimeBounceFlag == FALSE)
1160   1          {
1161   2              if(CmpData.CCD.wRingTime > NearestData.wRingTime)
1162   2              {
1163   3                  /* Compute the difference between the ring time saved and this time detected. */
1164   3                  wRingTimeDiff = CmpData.CCD.wRingTime - NearestData.wRingTime;
1165   3                  if(wRingTimeDiff > RING_TIME_CHANGE_THRESHOLD)
1166   3                  {
1167   4                      if(CmpData.CCD.wRingTime > RING_TIME_MAX_VALUE)
1168   4                      {
1169   5                          CmpData.CCD.bObsDistance[0] = OBSTACLE_IN_RING_TIME_VALUE;
1170   5                          if(CmpData.CCD.bDataNum < OBJ_NUM)
1171   5                          {
1172   6                              CmpData.CCD.bDataNum++;
1173   6                          }
1174   5                      }
1175   4                      else
1176   4                      {
1177   5                          if(wRingTimeDiff > OBSTALE_IN_RING_TIME_THRESHOLD)
1178   5                          {
1179   6                              CmpData.CCD.bObsDistance[0] = OBSTACLE_IN_RING_TIME_VALUE;
1180   6                              if(CmpData.CCD.bDataNum < OBJ_NUM)
1181   6                              {
1182   7                                  CmpData.CCD.bDataNum++;
1183   7                              }
1184   6                          }
1185   5                          else
1186   5                          {
1187   6                              CmpData.CCD.bObsDistance[0] = NearestData.bEachNearestDistance[DetInfo.bID];
1188   6                              if(CmpData.CCD.bDataNum == 0 )
1189   6                              {
1190   7                                  CmpData.CCD.bDataNum ++;
1191   7                              }
1192   6                          }
1193   5                      }
1194   4                  }
1195   3              }
1196   2              else
1197   2              {
1198   3              }
1199   2          }
1200   1      }
1201          
1202          
1203          /*********************************************************************************************************
             -************
1204          ** Compare the obstacle received after sending two times of the ultrasonic.
1205          **********************************************************************************************************
             -***********/
1206          void DetObj_CompareTheData(void)
1207          {
1208   1          WORD  xdata RingTimeDiff;
C51 COMPILER V9.60.0.0   DETECTOBJ                                                         08/08/2020 16:35:49 PAGE 21  

1209   1          BYTE  xdata DistanceDiff;
1210   1          BYTE  xdata bObsDistance[OBJ_NUM];
1211   1          BYTE  xdata bEPDObsDistance[OBJ_NUM];
1212   1          BYTE  xdata k = 0;
1213   1          BYTE  xdata i,j;
1214   1      
1215   1          if(CmpData.bFirstDataFlag == TRUE)
1216   1          {
1217   2              CmpData.bFirstDataFlag = FALSE;
1218   2              /* Save the data first time received. */
1219   2              j = 0;
1220   2              for(i=0;i<CmpData.EPD[CmpData.bCurBfNumber].bDataNum;i++)
1221   2              {
1222   3                  if(CmpData.EPD[CmpData.bCurBfNumber].bObsDistance[i] != NO_OBJ)
1223   3                  {
1224   4                      CmpData.CCD.bObsDistance[j] = CmpData.EPD[CmpData.bCurBfNumber].bObsDistance[i];
1225   4                      j++;
1226   4                  }
1227   3              }
1228   2              CmpData.CCD.bDataNum = j;
1229   2              CmpData.CCD.wRingTime = CmpData.EPD[CmpData.bCurBfNumber].wRingTime;
1230   2      
1231   2              if(NearestData.bRingTimeFlag == 0)
1232   2              {
1233   3                  if(CmpData.CCD.bDataNum ==0)
1234   3                  {
1235   4                      if(CmpData.EPD[CmpData.bCurBfNumber].wRingTime < (NearestData.wRingTime + RENEW_RING_TIME_
             -THRESHOLD))
1236   4                      {
1237   5                          DetInfo.bDetTimes = 0;/*exit*/
1238   5                      }
1239   4                  }
1240   3              }
1241   2          }
1242   1          else
1243   1          {
1244   2              /* Compare the ring time. */
1245   2              if(CmpData.EPD[CmpData.bCurBfNumber].wRingTime > CmpData.CCD.wRingTime)
1246   2              {
1247   3                  RingTimeDiff = CmpData.EPD[CmpData.bCurBfNumber].wRingTime - CmpData.CCD.wRingTime;
1248   3              }
1249   2              else
1250   2              {
1251   3                  RingTimeDiff = CmpData.CCD.wRingTime - CmpData.EPD[CmpData.bCurBfNumber].wRingTime;
1252   3              }
1253   2              if(RingTimeDiff < RENEW_RING_TIME_THRESHOLD)/*if the value is so small maybe inferrence the EMC*/
1254   2              {
1255   3                  NearestData.bRingTimeBounceFlag = FALSE;
1256   3                  CmpData.CCD.wRingTime = CmpData.EPD[CmpData.bCurBfNumber].wRingTime;
1257   3              }
1258   2              else
1259   2              {
1260   3                  /* hold the distance */
1261   3                  CmpData.CCD.bObsDistance[0] = NearestData.bEachNearestDistance[DetInfo.bID];
1262   3                  if(CmpData.CCD.bDataNum < OBJ_NUM)
1263   3                  {
1264   4                      CmpData.CCD.bDataNum++;
1265   4                  }
1266   3                  NearestData.bRingTimeBounceFlag = TRUE;
1267   3                  return; /* return; keep distance, dont compare data, Possible loss of distance*/
1268   3              }
1269   2      
1270   2              for(i=0; i<OBJ_NUM; i++)
C51 COMPILER V9.60.0.0   DETECTOBJ                                                         08/08/2020 16:35:49 PAGE 22  

1271   2              {
1272   3                  bEPDObsDistance[i] = CmpData.EPD[CmpData.bCurBfNumber].bObsDistance[i];
1273   3              }
1274   2              k = 0;
1275   2              for(i=0;i<CmpData.CCD.bDataNum;i++)
1276   2              {
1277   3                  for(j=0;j<CmpData.EPD[CmpData.bCurBfNumber].bDataNum;j++)
1278   3                  {
1279   4                      if(bEPDObsDistance[j] != NO_OBJ)
1280   4                      {
1281   5                          /* Compute the difference */
1282   5                          if(CmpData.CCD.bObsDistance[i] > bEPDObsDistance[j])
1283   5                          {
1284   6                              DistanceDiff = CmpData.CCD.bObsDistance[i] - bEPDObsDistance[j];
1285   6                          } else {
1286   6                              DistanceDiff = bEPDObsDistance[j] - CmpData.CCD.bObsDistance[i];
1287   6                          }
1288   5                          if(DistanceDiff < COMPARE_DIFFERENCE)
1289   5                          {
1290   6                              /* The data is valid. */
1291   6                              bObsDistance[k] = bEPDObsDistance[j];
1292   6                              bEPDObsDistance[j] = NO_OBJ;
1293   6                              k++;
1294   6                          }
1295   5                      }
1296   4                  }
1297   3              }
1298   2      
1299   2              /* Save the data to buff. */
1300   2              for(i=0;i<k;i++)
1301   2              {
1302   3                  CmpData.CCD.bObsDistance[i] = bObsDistance[i];
1303   3              }
1304   2              CmpData.CCD.bDataNum = k;
1305   2      
1306   2              if(CmpData.CCD.bDataNum == 0 &&
1307   2                 CmpData.CCD.wRingTime < (NearestData.wRingTime + RING_TIME_CHANGE_THRESHOLD))
1308   2              {
1309   3                  /* Change to next sensor. */
1310   3                  DetInfo.bDetTimes = 0;
1311   3              }
1312   2          }
1313   1      
1314   1      #ifdef RINGTIME_RENEW
                  static BYTE  xdata RingTimeCnt = 0;
                  static DWORD xdata RingTimeBuffer = 0;
              
                  if(RingTimeCnt < 16)
                  {
                      RingTimeCnt++;
                      RingTimeBuffer += CmpData.EPD[CmpData.bCurBfNumber].wRingTime;
                  }
                  else
                  {
                      RingTimeBuffer >>= 4;
                      if(RingTimeBuffer < NearestData.wRingTime)
                          NearestData.wRingTime  = RingTimeBuffer;
                      RingTimeBuffer = 0;
                      RingTimeCnt = 0;
                  }
              #endif
1332   1      
1333   1      }
C51 COMPILER V9.60.0.0   DETECTOBJ                                                         08/08/2020 16:35:49 PAGE 23  



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   5081    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    477      61
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     90      14
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
